"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AccountResolver: () => AccountResolver,
  AgentMode: () => AgentMode,
  HederaAIToolkit: () => toolkit_default3,
  HederaLangchainToolkit: () => toolkit_default,
  HederaMCPToolkit: () => toolkit_default2,
  PluginRegistry: () => PluginRegistry,
  PromptGenerator: () => PromptGenerator,
  ToolDiscovery: () => ToolDiscovery,
  coreAccountPlugin: () => coreAccountPlugin,
  coreAccountPluginToolNames: () => coreAccountPluginToolNames,
  coreConsensusPlugin: () => coreConsensusPlugin,
  coreConsensusPluginToolNames: () => coreConsensusPluginToolNames,
  coreHTSPlugin: () => coreHTSPlugin,
  coreHTSPluginToolNames: () => coreHTSPluginToolNames,
  coreQueriesPlugin: () => coreQueriesPlugin,
  coreQueriesPluginToolNames: () => coreQueriesPluginToolNames,
  handleTransaction: () => handleTransaction
});
module.exports = __toCommonJS(index_exports);

// src/shared/api.ts
var HederaAgentAPI = class {
  client;
  context;
  tools;
  constructor(client, context, tools) {
    this.client = client;
    if (!this.client.ledgerId) {
      throw new Error("Client must be connected to a network");
    }
    this.context = context || {};
    this.tools = tools || [];
  }
  async run(method, arg) {
    const tool13 = this.tools.find((t) => t.method === method);
    if (tool13) {
      const output = JSON.stringify(await tool13.execute(this.client, this.context, arg));
      return output;
    } else {
      throw new Error("Invalid method " + method);
    }
  }
};
var api_default = HederaAgentAPI;

// src/shared/configuration.ts
var AgentMode = /* @__PURE__ */ ((AgentMode2) => {
  AgentMode2["AUTONOMOUS"] = "autonomous";
  AgentMode2["RETURN_BYTES"] = "returnBytes";
  return AgentMode2;
})(AgentMode || {});

// src/shared/plugin.ts
var PluginRegistry = class {
  plugins = /* @__PURE__ */ new Map();
  register(plugin) {
    if (this.plugins.has(plugin.name)) {
      console.warn(`Plugin "${plugin.name}" is already registered. Overwriting.`);
    }
    this.plugins.set(plugin.name, plugin);
  }
  getPlugins() {
    return Array.from(this.plugins.values());
  }
  getTools(context) {
    const pluginTools = [];
    for (const plugin of this.plugins.values()) {
      try {
        const tools = plugin.tools(context);
        pluginTools.push(...tools);
      } catch (error) {
        console.error(`Error loading tools from plugin "${plugin.name}":`, error);
      }
    }
    return pluginTools;
  }
  clear() {
    this.plugins.clear();
  }
};

// src/shared/tool-discovery.ts
var ToolDiscovery = class _ToolDiscovery {
  pluginRegistry = new PluginRegistry();
  constructor(plugins = []) {
    plugins.forEach((plugin) => this.pluginRegistry.register(plugin));
  }
  getAllTools(context, configuration) {
    const pluginTools = this.pluginRegistry.getTools(context);
    const allTools = [];
    const allToolNames = /* @__PURE__ */ new Set();
    pluginTools.forEach((pluginTool) => {
      if (!allToolNames.has(pluginTool.method)) {
        allTools.push(pluginTool);
        allToolNames.add(pluginTool.method);
      } else {
        console.warn(
          `Plugin tool "${pluginTool.method}" conflicts with core tool. Using core tool.`
        );
      }
    });
    if (configuration?.tools && configuration.tools.length > 0) {
      return allTools.filter((tool13) => configuration.tools.includes(tool13.method));
    }
    return allTools;
  }
  static createFromConfiguration(configuration) {
    return new _ToolDiscovery(configuration.plugins || []);
  }
};

// src/shared/strategies/tx-mode-strategy.ts
var import_sdk = require("@hashgraph/sdk");
var ExecuteStrategy = class {
  async handle(tx, client) {
    const submit = await tx.execute(client);
    const receipt = await submit.getReceipt(client);
    return {
      status: receipt.status._code,
      accountId: receipt.accountId,
      tokenId: receipt.tokenId,
      transactionId: tx.transactionId,
      topicId: receipt.topicId,
      contractId: receipt.contractId,
      receipt
    };
  }
};
var ReturnBytesStrategy = class {
  async handle(tx, _client, context) {
    if (!context.accountId) throw new Error("\u2026");
    const id = import_sdk.TransactionId.generate(context.accountId);
    tx.setNodeAccountIds([new import_sdk.AccountId(4), new import_sdk.AccountId(5)]).setTransactionId(id).freeze();
    return { bytes: tx.toBytes() };
  }
};
var getStrategyFromContext = (context) => {
  if (context.mode === "returnBytes" /* RETURN_BYTES */) {
    return new ReturnBytesStrategy();
  }
  return new ExecuteStrategy();
};
var handleTransaction = async (tx, client, context) => {
  const strategy = getStrategyFromContext(context);
  return await strategy.handle(tx, client, context);
};

// src/shared/utils/account-resolver.ts
var AccountResolver = class {
  /**
   * Gets the default account based on the agent mode and context.
   * In RETURN_BYTES mode, prefers context.accountId (user's account).
   * In AUTONOMOUS mode or when no context account, uses operator account.
   */
  static getDefaultAccount(context, client) {
    if (context.mode === "returnBytes" /* RETURN_BYTES */ && context.accountId) {
      return context.accountId;
    }
    const operatorAccount = client.operatorAccountId?.toString();
    if (!operatorAccount) {
      throw new Error("No account available: neither context.accountId nor operator account");
    }
    return operatorAccount;
  }
  /**
   * Resolves an account ID, using the provided account or falling back to the default.
   */
  static resolveAccount(providedAccount, context, client) {
    return providedAccount || this.getDefaultAccount(context, client);
  }
  /**
   * Gets a description of which account will be used as default for prompts.
   */
  static getDefaultAccountDescription(context) {
    if (context.mode === "returnBytes" /* RETURN_BYTES */ && context.accountId) {
      return `user account (${context.accountId})`;
    }
    return "operator account";
  }
};

// src/shared/utils/prompt-generator.ts
var PromptGenerator = class {
  /**
   * Generates a consistent context snippet for tool prompts.
   */
  static getContextSnippet(context) {
    const lines = ["Context:"];
    if (context.mode === "returnBytes" /* RETURN_BYTES */) {
      lines.push(`- Mode: Return Bytes (preparing transactions for user signing)`);
      if (context.accountId) {
        lines.push(`- User Account: ${context.accountId} (default for transaction parameters)`);
        lines.push(`- When no account is specified, ${context.accountId} will be used`);
      } else {
        lines.push(`- User Account: Not specified`);
        lines.push(`- When no account is specified, the operator account will be used`);
      }
    } else if (context.mode === "autonomous" /* AUTONOMOUS */) {
      lines.push(`- Mode: Autonomous (agent executes transactions directly)`);
      if (context.accountId) {
        lines.push(`- User Account: ${context.accountId}`);
      }
      lines.push(`- When no account is specified, the operator account will be used`);
    } else {
      lines.push(`- Mode: ${context.mode || "Not specified"}`);
      if (context.accountId) {
        lines.push(`- User Account: ${context.accountId}`);
      }
      lines.push(`- Default account will be determined at execution time`);
    }
    return lines.join("\n");
  }
  /**
   * Generates a consistent description for optional account parameters.
   */
  static getAccountParameterDescription(paramName, context, isRequired = false) {
    if (isRequired) {
      return `${paramName} (str, required): The Hedera account ID`;
    }
    const defaultAccountDesc = AccountResolver.getDefaultAccountDescription(context);
    return `${paramName} (str, optional): The Hedera account ID. If not provided, defaults to the ${defaultAccountDesc}`;
  }
  /**
   * Generates consistent parameter usage instructions.
   */
  static getParameterUsageInstructions() {
    return `
Important:
- Only include optional parameters if explicitly provided by the user
- Do not generate placeholder values for optional fields
- Leave optional parameters undefined if not specified by the user`;
  }
};

// src/langchain/tool.ts
var import_tools = require("@langchain/core/tools");
var HederaAgentKitTool = class extends import_tools.StructuredTool {
  hederaAPI;
  method;
  name;
  description;
  schema;
  constructor(HederaAgentKitAPI, method, description, schema) {
    super();
    this.hederaAPI = HederaAgentKitAPI;
    this.method = method;
    this.name = method;
    this.description = description;
    this.schema = schema;
  }
  _call(arg, _runManager, _parentConfig) {
    return this.hederaAPI.run(this.method, arg);
  }
};
var tool_default = HederaAgentKitTool;

// src/langchain/toolkit.ts
var HederaLangchainToolkit = class {
  _hederaAgentKit;
  tools;
  constructor({ client, configuration }) {
    const context = configuration.context || {};
    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);
    const allTools = toolDiscovery.getAllTools(context, configuration);
    this._hederaAgentKit = new api_default(client, configuration.context, allTools);
    this.tools = allTools.map(
      (tool13) => new tool_default(
        this._hederaAgentKit,
        tool13.method,
        tool13.description,
        tool13.parameters
      )
    );
  }
  getTools() {
    return this.tools;
  }
};
var toolkit_default = HederaLangchainToolkit;

// src/modelcontextprotocol/toolkit.ts
var import_mcp = require("@modelcontextprotocol/sdk/server/mcp.js");
var HederaMCPToolkit = class extends import_mcp.McpServer {
  _hederaAgentKit;
  constructor({ client, configuration }) {
    super({
      name: "Hedera Agent Kit",
      version: "0.1.0",
      configuration: {
        ...configuration,
        context: {
          ...configuration.context,
          mode: "modelcontextprotocol"
        }
      }
    });
    const context = configuration.context || {};
    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);
    const allTools = toolDiscovery.getAllTools(context, configuration);
    this._hederaAgentKit = new api_default(client, configuration.context, allTools);
    allTools.map((tool13) => {
      this.tool(
        tool13.method,
        tool13.description,
        tool13.parameters.shape,
        async (arg, _extra) => {
          const result = await this._hederaAgentKit.run(tool13.method, arg);
          return {
            content: [
              {
                type: "text",
                text: String(result)
              }
            ]
          };
        }
      );
    });
  }
};
var toolkit_default2 = HederaMCPToolkit;

// src/ai-sdk/tool.ts
var import_ai = require("ai");
function HederaAgentKitTool2(hederaAPI, method, description, schema) {
  return (0, import_ai.tool)({
    description,
    parameters: schema,
    execute: (arg) => {
      return hederaAPI.run(method, arg);
    }
  });
}

// src/ai-sdk/toolkit.ts
var HederaAIToolkit = class {
  _hedera;
  tools;
  constructor({ client, configuration }) {
    const context = configuration.context || {};
    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);
    const allTools = toolDiscovery.getAllTools(context, configuration);
    this._hedera = new api_default(client, configuration.context, allTools);
    this.tools = {};
    allTools.forEach((tool13) => {
      this.tools[tool13.method] = HederaAgentKitTool2(
        this._hedera,
        tool13.method,
        tool13.description,
        tool13.parameters
      );
    });
  }
  middleware() {
    return {
      wrapGenerate: async ({ doGenerate }) => {
        return doGenerate();
      },
      wrapStream: async ({ doStream }) => {
        return doStream();
      }
    };
  }
  getTools() {
    return this.tools;
  }
};
var toolkit_default3 = HederaAIToolkit;

// src/shared/hedera-utils/hedera-parameter-normaliser.ts
var import_sdk2 = require("@hashgraph/sdk");

// src/shared/hedera-utils/decimals-utils.ts
function toBaseUnit(amount, decimals) {
  return Math.floor(amount * 10 ** decimals);
}

// src/shared/hedera-utils/hedera-parameter-normaliser.ts
var import_long = __toESM(require("long"));
var HederaParameterNormaliser = class {
  static async normaliseCreateFungibleTokenParams(params, context, client, mirrorNode) {
    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);
    const normalized = {
      ...params,
      supplyType: import_sdk2.TokenSupplyType.Finite,
      // defaults to finite supply
      autoRenewAccountId: defaultAccountId
    };
    const treasuryAccountId = params.treasuryAccountId ?? defaultAccountId;
    if (!treasuryAccountId) {
      throw new Error("Must include treasury account ID");
    }
    const supplyTypeString = params.supplyType ?? "infinite";
    const supplyType = supplyTypeString === "finite" ? import_sdk2.TokenSupplyType.Finite : import_sdk2.TokenSupplyType.Infinite;
    const decimals = params.decimals ?? 0;
    const initialSupply = toBaseUnit(params.initialSupply ?? 0, decimals);
    let maxSupply = void 0;
    if (supplyTypeString === "finite") {
      if (!params.maxSupply) {
        throw new Error("Must include max supply for finite supply type");
      }
      maxSupply = toBaseUnit(params.maxSupply, decimals);
      if (initialSupply > maxSupply) {
        throw new Error(
          `Initial supply (${initialSupply}) cannot exceed max supply (${maxSupply})`
        );
      }
    }
    const publicKey = await mirrorNode.getAccount(defaultAccountId).then((r) => r.accountPublicKey) ?? client.operatorPublicKey?.toStringDer();
    if (params.isSupplyKey === true) {
      normalized.supplyKey = import_sdk2.PublicKey.fromString(publicKey);
    }
    const autoRenewAccountId = defaultAccountId;
    return {
      ...normalized,
      treasuryAccountId,
      supplyType,
      maxSupply,
      decimals,
      initialSupply,
      autoRenewAccountId
    };
  }
  static async normaliseCreateNonFungibleTokenParams(params, context, client, mirrorNode) {
    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);
    const treasuryAccountId = params.treasuryAccountId || defaultAccountId;
    if (!treasuryAccountId) throw new Error("Must include treasury account ID");
    const publicKey = await mirrorNode.getAccount(defaultAccountId).then((r) => r.accountPublicKey) ?? client.operatorPublicKey?.toStringDer();
    const maxSupply = params.maxSupply ?? 100;
    const normalized = {
      ...params,
      treasuryAccountId,
      maxSupply,
      supplyKey: import_sdk2.PublicKey.fromString(publicKey),
      // the supply key is mandatory in the case of NFT
      supplyType: import_sdk2.TokenSupplyType.Finite,
      // NFTs supply must be finite
      autoRenewAccountId: defaultAccountId,
      tokenType: import_sdk2.TokenType.NonFungibleUnique
    };
    return normalized;
  }
  static normaliseTransferHbar(params, context, client) {
    const sourceAccountId = AccountResolver.resolveAccount(params.sourceAccountId, context, client);
    const hbarTransfers = [];
    let totalTinybars = import_long.default.ZERO;
    for (const transfer of params.transfers) {
      const amount = new import_sdk2.Hbar(transfer.amount);
      if (amount.isNegative() || amount.toTinybars().equals(import_long.default.ZERO)) {
        throw new Error(`Invalid transfer amount: ${transfer.amount}`);
      }
      totalTinybars = totalTinybars.add(amount.toTinybars());
      hbarTransfers.push({
        accountId: transfer.accountId,
        amount
      });
    }
    hbarTransfers.push({
      accountId: sourceAccountId,
      amount: import_sdk2.Hbar.fromTinybars(totalTinybars.negate())
    });
    return {
      hbarTransfers,
      transactionMemo: params.transactionMemo
    };
  }
  static async normaliseAirdropFungibleTokenParams(params, context, client, mirrorNode) {
    const sourceAccountId = AccountResolver.resolveAccount(params.sourceAccountId, context, client);
    const tokenDetails = await mirrorNode.getTokenDetails(params.tokenId);
    const tokenDecimals = parseInt(tokenDetails.decimals, 10);
    const tokenTransfers = [];
    let totalAmount = import_long.default.ZERO;
    for (const recipient of params.recipients) {
      const amountRaw = Number(recipient.amount);
      if (amountRaw <= 0) {
        throw new Error(`Invalid recipient amount: ${recipient.amount}`);
      }
      const amount = import_long.default.fromString(toBaseUnit(amountRaw, tokenDecimals).toString());
      totalAmount = totalAmount.add(amount);
      tokenTransfers.push({
        tokenId: params.tokenId,
        accountId: recipient.accountId,
        amount
      });
    }
    tokenTransfers.push({
      tokenId: params.tokenId,
      accountId: sourceAccountId,
      amount: totalAmount.negate()
    });
    return {
      tokenTransfers
    };
  }
  static async normaliseCreateTopicParams(params, context, client, mirrorNode) {
    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);
    const normalised = {
      ...params,
      autoRenewAccountId: defaultAccountId
    };
    if (params.isSubmitKey) {
      const publicKey = await mirrorNode.getAccount(defaultAccountId).then((r) => r.accountPublicKey) ?? client.operatorPublicKey?.toStringDer();
      if (!publicKey) {
        throw new Error("Could not determine default account ID for submit key");
      }
      normalised.submitKey = import_sdk2.PublicKey.fromString(publicKey);
    }
    return normalised;
  }
  static normaliseHbarBalanceParams(params, context, client) {
    const accountId = AccountResolver.resolveAccount(params.accountId, context, client);
    return {
      ...params,
      accountId
    };
  }
  static normaliseAccountTokenBalancesParams(params, context, client) {
    const accountId = AccountResolver.resolveAccount(params.accountId, context, client);
    return {
      ...params,
      accountId
    };
  }
  static async normaliseMintFungibleTokenParams(params, context, mirrorNode) {
    const decimals = await mirrorNode.getTokenDetails(params.tokenId).then((r) => Number(r.decimals)) ?? 0;
    const baseAmount = toBaseUnit(params.amount, decimals);
    return {
      tokenId: params.tokenId,
      amount: baseAmount
    };
  }
  static normaliseMintNonFungibleTokenParams(params, _context) {
    const encoder = new TextEncoder();
    const metadata = params.uris.map((uri) => encoder.encode(uri));
    return {
      ...params,
      metadata
    };
  }
};

// src/shared/parameter-schemas/hts.zod.ts
var import_zod = require("zod");
var import_sdk3 = require("@hashgraph/sdk");
var createFungibleTokenParameters = (_context = {}) => import_zod.z.object({
  tokenName: import_zod.z.string().describe("The name of the token."),
  tokenSymbol: import_zod.z.string().describe("The symbol of the token."),
  initialSupply: import_zod.z.number().int().default(0).describe("The initial supply of the token."),
  supplyType: import_zod.z.enum(["finite", "infinite"]).optional().describe("Supply type of the token."),
  maxSupply: import_zod.z.number().int().optional().describe("The maximum supply of the token."),
  decimals: import_zod.z.number().int().optional().default(0).describe("The number of decimals."),
  treasuryAccountId: import_zod.z.string().optional().describe("The treasury account of the token."),
  isSupplyKey: import_zod.z.boolean().optional().describe("Determines if the token supply key should be set.")
});
var createNonFungibleTokenParameters = (_context = {}) => import_zod.z.object({
  tokenName: import_zod.z.string().describe("The name of the token."),
  tokenSymbol: import_zod.z.string().describe("The symbol of the token."),
  maxSupply: import_zod.z.number().int().optional().default(100).describe("The maximum supply of the token."),
  treasuryAccountId: import_zod.z.string().optional().describe("The treasury account of the token.")
});
var AirdropRecipientSchema = import_zod.z.object({
  accountId: import_zod.z.string().describe('Recipient account ID (e.g., "0.0.xxxx").'),
  amount: import_zod.z.union([import_zod.z.number(), import_zod.z.string()]).describe("Amount in base unit.")
});
var airdropFungibleTokenParameters = (_context = {}) => import_zod.z.object({
  tokenId: import_zod.z.string().describe("The id of the token."),
  amount: import_zod.z.number().describe("The amount of tokens to airdrop."),
  sourceAccountId: import_zod.z.string().optional().describe("The account to airdrop the token from."),
  recipients: import_zod.z.array(AirdropRecipientSchema).min(1).describe("Array of recipient objects, each with accountId and amount.")
});
var mintFungibleTokenParameters = (_context = {}) => import_zod.z.object({
  tokenId: import_zod.z.string().describe("The id of the token."),
  amount: import_zod.z.number().describe("The amount of tokens to mint.")
});
var mintNonFungibleTokenParameters = (_context = {}) => import_zod.z.object({
  tokenId: import_zod.z.string().describe("The id of the NFT class."),
  uris: import_zod.z.array(import_zod.z.string().max(100)).max(10).describe("An array of URIs hosting NFT metadata.")
});

// src/shared/hedera-utils/hedera-builder.ts
var import_sdk4 = require("@hashgraph/sdk");
var HederaBuilder = class {
  static createFungibleToken(params) {
    return new import_sdk4.TokenCreateTransaction(params);
  }
  static createNonFungibleToken(params) {
    return new import_sdk4.TokenCreateTransaction(params);
  }
  static transferHbar(params) {
    return new import_sdk4.TransferTransaction(params);
  }
  static airdropFungibleToken(params) {
    return new import_sdk4.TokenAirdropTransaction(params);
  }
  static createTopic(params) {
    return new import_sdk4.TopicCreateTransaction(params);
  }
  static submitTopicMessage(params) {
    return new import_sdk4.TopicMessageSubmitTransaction(params);
  }
  static mintFungibleToken(params) {
    return new import_sdk4.TokenMintTransaction(params);
  }
  static mintNonFungibleToken(params) {
    return new import_sdk4.TokenMintTransaction(params);
  }
};

// src/shared/hedera-utils/mirrornode/types.ts
var import_sdk5 = require("@hashgraph/sdk");
var LedgerIdToBaseUrl = /* @__PURE__ */ new Map([
  [import_sdk5.LedgerId.MAINNET.toString(), "https://mainnet-public.mirrornode.hedera.com/api/v1"],
  [import_sdk5.LedgerId.TESTNET.toString(), "https://testnet.mirrornode.hedera.com/api/v1"]
]);

// src/shared/hedera-utils/mirrornode/hedera-mirrornode-service-default-impl.ts
var import_bignumber = __toESM(require("bignumber.js"));
var HederaMirrornodeServiceDefaultImpl = class {
  constructor(ledgerId) {
    this.ledgerId = ledgerId;
    if (!LedgerIdToBaseUrl.has(ledgerId.toString())) {
      throw new Error(`Network type ${ledgerId} not supported`);
    }
    this.baseUrl = LedgerIdToBaseUrl.get(ledgerId.toString());
  }
  baseUrl;
  async getAccount(accountId) {
    const url = `${this.baseUrl}/accounts/${accountId}`;
    const response = await fetch(url);
    const data = await response.json();
    return {
      accountId: data.accountId,
      accountPublicKey: data.key.key,
      balance: data.balance
    };
  }
  async getAccountHBarBalance(accountId) {
    const account = await this.getAccount(accountId);
    return new import_bignumber.default(account.balance.balance);
  }
  async getAccountTokenBalances(accountId, tokenId) {
    const tokenIdParam = tokenId ? `&token.id=${tokenId}` : "";
    const url = `${this.baseUrl}/accounts/${accountId}/tokens?${tokenIdParam}`;
    const response = await fetch(url);
    return await response.json();
  }
  async getTopicMessages(queryParams) {
    const lowerThreshold = queryParams.lowerTimestamp ? `&timestamp=gte:${queryParams.lowerTimestamp}` : "";
    const upperThreshold = queryParams.upperTimestamp ? `&timestamp=lte:${queryParams.upperTimestamp}` : "";
    const baseParams = `&order=desc&limit=100`;
    let url = `${this.baseUrl}/topics/${queryParams.topicId}/messages?${lowerThreshold}${upperThreshold}${baseParams}`;
    const arrayOfMessages = [];
    let fetchedMessages = 0;
    try {
      while (url) {
        fetchedMessages += 1;
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(
            `HTTP error! status: ${response.status}. Message: ${response.statusText}`
          );
        }
        const data = await response.json();
        arrayOfMessages.push(...data.messages);
        if (fetchedMessages >= 100) {
          break;
        }
        url = data.links.next ? this.baseUrl + data.links.next : null;
      }
    } catch (error) {
      console.error("Failed to fetch topic messages. Error:", error);
      throw error;
    }
    return {
      topicId: queryParams.topicId,
      messages: arrayOfMessages.slice(0, queryParams.limit)
    };
  }
  async getTokenDetails(tokenId) {
    const url = `${this.baseUrl}/tokens/${tokenId}`;
    const response = await fetch(url);
    return await response.json();
  }
};

// src/shared/hedera-utils/mirrornode/hedera-mirrornode-utils.ts
var getMirrornodeService = (mirrornodeService, ledgerId) => {
  if (mirrornodeService) {
    return mirrornodeService;
  }
  return new HederaMirrornodeServiceDefaultImpl(ledgerId);
};

// src/plugins/core-hts-plugin/tools/fungible-token/airdrop-fungible-token.ts
var airdropFungibleTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(
    "sourceAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will airdrop a fungible token on Hedera.

Parameters:
- tokenId (str, required): The id of the token
- ${sourceAccountDesc}
- recipients (array, required): A list of recipient objects, each containing:
  - accountId (string): The recipient's account ID (e.g., "0.0.1234")
  - amount (number or string): The amount of tokens to send to that recipient (in base units)
- transactionMemo (str, optional): Optional memo for the transaction
${usageInstructions}
`;
};
var airdropFungibleToken = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseAirdropFungibleTokenParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.airdropFungibleToken(normalisedParams);
    const result = await handleTransaction(tx, client, context);
    return result;
  } catch (error) {
    if (error instanceof Error) {
      return error.message;
    }
    return "Failed to airdrop fungible token";
  }
};
var AIRDROP_FUNGIBLE_TOKEN_TOOL = "airdrop_fungible_token_tool";
var tool2 = (context) => ({
  method: AIRDROP_FUNGIBLE_TOKEN_TOOL,
  name: "Airdrop Fungible Token",
  description: airdropFungibleTokenPrompt(context),
  parameters: airdropFungibleTokenParameters(context),
  execute: airdropFungibleToken
});
var airdrop_fungible_token_default = tool2;

// src/plugins/core-hts-plugin/tools/fungible-token/create-fungible-token.ts
var createFungibleTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const treasuryAccountDesc = PromptGenerator.getAccountParameterDescription(
    "treasuryAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool creates a fungible token on Hedera.

Parameters:
- tokenName (str, required): The name of the token
- tokenSymbol (str, optional): The symbol of the token
- initialSupply (int, optional): The initial supply of the token
- supplyType (str, optional): The supply type of the token. Can be "finite" or "infinite". Defaults to "finite"
- maxSupply (int, optional): The maximum supply of the token. Only applicable if supplyType is "finite". Defaults to 1,000,000 if not specified
- decimals (int, optional): The number of decimals the token supports. Defaults to 0
- ${treasuryAccountDesc}
- isSupplyKey (boolean, optional): If user wants to set supply key set to true, otherwise false
${usageInstructions}
`;
};
var createFungibleToken = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseCreateFungibleTokenParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.createFungibleToken(normalisedParams);
    const result = await handleTransaction(tx, client, context);
    return result;
  } catch (error) {
    console.error("[CreateFungibleToken] Error creating fungible token:", error);
    if (error instanceof Error) {
      return error.message;
    }
    return "Failed to create fungible token";
  }
};
var CREATE_FUNGIBLE_TOKEN_TOOL = "create_fungible_token_tool";
var tool3 = (context) => ({
  method: CREATE_FUNGIBLE_TOKEN_TOOL,
  name: "Create Fungible Token",
  description: createFungibleTokenPrompt(context),
  parameters: createFungibleTokenParameters(context),
  execute: createFungibleToken
});
var create_fungible_token_default = tool3;

// src/plugins/core-hts-plugin/tools/fungible-token/mint-fungible-token.ts
var mintFungibleTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will mint a given amount (supply) of an existing fungible token on Hedera.

Parameters:
- tokenId (str, required): The id of the token
- amount (number, required): The amount to be minted
${usageInstructions}

Example: "Mint 1 of 0.0.6458037" means minting the amount of 1 of the token with id 0.0.6458037.
`;
};
var mintFungibleToken = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseMintFungibleTokenParams(
      params,
      context,
      mirrornodeService
    );
    const tx = HederaBuilder.mintFungibleToken(normalisedParams);
    const result = await handleTransaction(tx, client, context);
    return result;
  } catch (error) {
    if (error instanceof Error) {
      return error.message;
    }
    return "Failed to mint fungible token";
  }
};
var MINT_FUNGIBLE_TOKEN_TOOL = "mint_fungible_token_tool";
var tool4 = (context) => ({
  method: MINT_FUNGIBLE_TOKEN_TOOL,
  name: "Mint Fungible Token",
  description: mintFungibleTokenPrompt(context),
  parameters: mintFungibleTokenParameters(context),
  execute: mintFungibleToken
});
var mint_fungible_token_default = tool4;

// src/plugins/core-hts-plugin/tools/non-fungible-token/create-non-fungible-token.ts
var createNonFungibleTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const treasuryAccountDesc = PromptGenerator.getAccountParameterDescription(
    "treasuryAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool creates a non-fungible token (NFT) on Hedera.

Parameters:
- tokenName (str, required): Name of the token
- tokenSymbol (str, required): Symbol of the token
- maxSupply (int, optional): Maximum NFT supply. Defaults to 100 if not provided
- ${treasuryAccountDesc}
${usageInstructions}
`;
};
var createNonFungibleToken = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseCreateNonFungibleTokenParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.createNonFungibleToken(normalisedParams);
    const result = await handleTransaction(tx, client, context);
    return result;
  } catch (error) {
    if (error instanceof Error) {
      return error.message;
    }
    return "Failed to create non-fungible token";
  }
};
var CREATE_NON_FUNGIBLE_TOKEN_TOOL = "create_non_fungible_token_tool";
var tool5 = (context) => ({
  method: CREATE_NON_FUNGIBLE_TOKEN_TOOL,
  name: "Create Non-Fungible Token",
  description: createNonFungibleTokenPrompt(context),
  parameters: createNonFungibleTokenParameters(context),
  execute: createNonFungibleToken
});
var create_non_fungible_token_default = tool5;

// src/plugins/core-hts-plugin/tools/non-fungible-token/mint-non-fungible-token.ts
var mintNonFungibleTokenPrompt = (_context = {}) => {
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `

This tool will mint NFTs with its unique metadata for the class of NFTs (non-fungible tokens) defined by the tokenId on Hedera.

Parameters:
- tokenId (str, required): The id of the token
- uris (array, required): An array of strings (URIs) of maximum size 10 hosting the NFT metadata
${usageInstructions}

Example: "Mint 0.0.6465503 with metadata: ipfs://bafyreiao6ajgsfji6qsgbqwdtjdu5gmul7tv2v3pd6kjgcw5o65b2ogst4/metadata.json" means minting an NFT with the given metadata URI for the class of NFTs defined by the token with id 0.0.6465503.
`;
};
var mintNonFungibleToken = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseMintNonFungibleTokenParams(
      params,
      context
    );
    const tx = HederaBuilder.mintNonFungibleToken(normalisedParams);
    const result = await handleTransaction(tx, client, context);
    return result;
  } catch (error) {
    if (error instanceof Error) {
      return error.message;
    }
    return "Failed to mint non-fungible token";
  }
};
var MINT_NON_FUNGIBLE_TOKEN_TOOL = "mint_non_fungible_token_tool";
var tool6 = (context) => ({
  method: MINT_NON_FUNGIBLE_TOKEN_TOOL,
  name: "Mint Non-Fungible Token",
  description: mintNonFungibleTokenPrompt(context),
  parameters: mintNonFungibleTokenParameters(context),
  execute: mintNonFungibleToken
});
var mint_non_fungible_token_default = tool6;

// src/plugins/core-hts-plugin/index.ts
var coreHTSPlugin = {
  name: "core-hts-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera Transaction Service",
  tools: (context) => {
    return [
      create_fungible_token_default(context),
      mint_fungible_token_default(context),
      create_non_fungible_token_default(context),
      airdrop_fungible_token_default(context),
      mint_non_fungible_token_default(context)
    ];
  }
};
var coreHTSPluginToolNames = {
  AIRDROP_FUNGIBLE_TOKEN_TOOL,
  CREATE_FUNGIBLE_TOKEN_TOOL,
  MINT_FUNGIBLE_TOKEN_TOOL,
  CREATE_NON_FUNGIBLE_TOKEN_TOOL,
  MINT_NON_FUNGIBLE_TOKEN_TOOL
};

// src/shared/parameter-schemas/has.zod.ts
var import_zod2 = require("zod");
var import_sdk6 = require("@hashgraph/sdk");
var import_bignumber2 = __toESM(require("bignumber.js"));
var import_long2 = __toESM(require("long"));
var transferHbarParameters = (_context = {}) => import_zod2.z.object({
  transfers: import_zod2.z.array(
    import_zod2.z.object({
      accountId: import_zod2.z.string().describe("Recipient account ID"),
      amount: import_zod2.z.number().describe("Amount of HBAR to transfer")
    })
  ).describe("Array of HBAR transfers"),
  sourceAccountId: import_zod2.z.string().optional().describe("Sender account ID"),
  transactionMemo: import_zod2.z.string().optional().describe("Memo to include with the transaction")
});

// src/plugins/core-account-plugin/tools/account/transfer-hbar.ts
var transferHbarPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(
    "sourceAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will transfer HBAR to an account.

Parameters:
- hbarAmount (number, required): Amount of HBAR to transfer
- destinationAccountId (str, required): Account to transfer HBAR to
- ${sourceAccountDesc}
- transactionMemo (str, optional): Optional memo for the transaction
${usageInstructions}
`;
};
var transferHbar = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseTransferHbar(
      params,
      context,
      client
    );
    const tx = HederaBuilder.transferHbar(normalisedParams);
    const result = await handleTransaction(tx, client, context);
    return result;
  } catch (error) {
    if (error instanceof Error) {
      return error.message;
    }
    return "Failed to transfer HBAR";
  }
};
var TRANSFER_HBAR_TOOL = "transfer_hbar_tool";
var tool7 = (context) => ({
  method: TRANSFER_HBAR_TOOL,
  name: "Transfer HBAR",
  description: transferHbarPrompt(context),
  parameters: transferHbarParameters(context),
  execute: transferHbar
});
var transfer_hbar_default = tool7;

// src/plugins/core-account-plugin/index.ts
var coreAccountPlugin = {
  name: "core-account-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera Account Service",
  tools: (context) => {
    return [transfer_hbar_default(context)];
  }
};
var coreAccountPluginToolNames = {
  TRANSFER_HBAR_TOOL
};

// src/shared/parameter-schemas/hcs.zod.ts
var import_zod3 = require("zod");
var createTopicParameters = (_context = {}) => {
  return import_zod3.z.object({
    isSubmitKey: import_zod3.z.boolean().optional().default(false).describe("Whether to set a submit key for the topic (optional)"),
    topicMemo: import_zod3.z.string().optional().describe("Memo for the topic (optional)")
  });
};
var submitTopicMessageParameters = (_context = {}) => {
  return import_zod3.z.object({
    topicId: import_zod3.z.string().describe("The ID of the topic to submit the message to"),
    message: import_zod3.z.string().describe("The message to submit to the topic")
  });
};

// src/plugins/core-consensus-plugin/tools/consensus/create-topic.ts
var createTopicPrompt = (_context = {}) => {
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
This tool will create a new topic on the Hedera network.

Parameters:
- topicMemo (str, optional): A memo for the topic
- isSubmitKey (bool, optional): Whether to set a submit key for the topic. Set to true if user wants to set a submit key, otherwise false
${usageInstructions}
`;
};
var createTopic = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(
      context.mirrornodeService,
      client.ledgerId
    );
    const normalisedParams = await HederaParameterNormaliser.normaliseCreateTopicParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.createTopic(normalisedParams);
    const result = await handleTransaction(tx, client, context);
    return result;
  } catch (error) {
    console.error("[CreateTopic] Error creating topic:", error);
    if (error instanceof Error) {
      return error.message;
    }
    return "Failed to create topic";
  }
};
var CREATE_TOPIC_TOOL = "create_topic_tool";
var tool8 = (context) => ({
  method: CREATE_TOPIC_TOOL,
  name: "Create Topic",
  description: createTopicPrompt(context),
  parameters: createTopicParameters(context),
  execute: createTopic
});
var create_topic_default = tool8;

// src/plugins/core-consensus-plugin/tools/consensus/submit-topic-message.ts
var submitTopicMessagePrompt = (_context = {}) => {
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
This tool will submit a message to a topic on the Hedera network.

Parameters:
- topicId (str, required): The ID of the topic to submit the message to
- message (str, required): The message to submit to the topic
${usageInstructions}
`;
};
var submitTopicMessage = async (client, context, params) => {
  try {
    const tx = HederaBuilder.submitTopicMessage(params);
    const result = await handleTransaction(tx, client, context);
    return result;
  } catch (error) {
    if (error instanceof Error) {
      return error.message;
    }
    return "Failed to submit message to topic";
  }
};
var SUBMIT_TOPIC_MESSAGE_TOOL = "submit_topic_message_tool";
var tool9 = (context) => ({
  method: SUBMIT_TOPIC_MESSAGE_TOOL,
  name: "Submit Topic Message",
  description: submitTopicMessagePrompt(context),
  parameters: submitTopicMessageParameters(context),
  execute: submitTopicMessage
});
var submit_topic_message_default = tool9;

// src/plugins/core-consensus-plugin/index.ts
var coreConsensusPlugin = {
  name: "core-consensus-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera Consensus Service",
  tools: (context) => {
    return [create_topic_default(context), submit_topic_message_default(context)];
  }
};
var coreConsensusPluginToolNames = {
  CREATE_TOPIC_TOOL,
  SUBMIT_TOPIC_MESSAGE_TOOL
};

// src/shared/parameter-schemas/account-query.zod.ts
var import_zod4 = require("zod");
var accountQueryParameters = (_context = {}) => import_zod4.z.object({
  accountId: import_zod4.z.string().describe("The account ID to query.")
});
var accountBalanceQueryParameters = (_context = {}) => import_zod4.z.object({
  accountId: import_zod4.z.string().optional().describe("The account ID to query.")
});
var accountTokenBalancesQueryParameters = (_context = {}) => import_zod4.z.object({
  accountId: import_zod4.z.string().optional().describe("The account ID to query. If not provided, this accountId will be used."),
  tokenId: import_zod4.z.string().optional().describe("The token ID to query.")
});
var topicMessagesQueryParameters = (_context = {}) => import_zod4.z.object({
  topicId: import_zod4.z.string().describe("The topic ID to query."),
  startTime: import_zod4.z.string().datetime().optional().describe(
    "The start time to query. If set, the messages will be returned after this timestamp."
  ),
  endTime: import_zod4.z.string().datetime().optional().describe(
    "The end time to query. If set, the messages will be returned before this timestamp."
  ),
  limit: import_zod4.z.number().optional().describe("The limit of messages to query. If set, the number of messages to return.")
});

// src/shared/hedera-utils/hbar-conversion-utils.ts
function toHBar(tinyBars) {
  return tinyBars.div(1e8);
}

// src/plugins/core-queries-plugin/tools/queries/get-hbar-balance-query.ts
var getHbarBalanceQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the HBAR balance for a given Hedera account.

Parameters:
- ${accountDesc}
${usageInstructions}
`;
};
var getHbarBalanceQuery = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseHbarBalanceParams(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const balance = await mirrornodeService.getAccountHBarBalance(
      normalisedParams.accountId
    );
    return { accountId: normalisedParams.accountId, hbarBalance: toHBar(balance).toString() };
  } catch (error) {
    if (error instanceof Error) {
      return error.message;
    }
    return "Failed to get HBAR balance";
  }
};
var GET_HBAR_BALANCE_QUERY_TOOL = "get_hbar_balance_query_tool";
var tool10 = (context) => ({
  method: GET_HBAR_BALANCE_QUERY_TOOL,
  name: "Get HBAR Balance",
  description: getHbarBalanceQueryPrompt(context),
  parameters: accountBalanceQueryParameters(context),
  execute: getHbarBalanceQuery
});
var get_hbar_balance_query_default = tool10;

// src/plugins/core-queries-plugin/tools/queries/get-account-query.ts
var getAccountQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the account information for a given Hedera account.

Parameters:
- accountId (str, required): The account ID to query
${usageInstructions}
`;
};
var getAccountQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const account = await mirrornodeService.getAccount(params.accountId);
    return { accountId: params.accountId, account };
  } catch (error) {
    console.error("Error getting account query", error);
    if (error instanceof Error) {
      return error.message;
    }
    return "Failed to get account query";
  }
};
var GET_ACCOUNT_QUERY_TOOL = "get_account_query_tool";
var getAccountQueryTool = (context) => ({
  method: GET_ACCOUNT_QUERY_TOOL,
  name: "Get Account Query",
  description: getAccountQueryPrompt(context),
  parameters: accountQueryParameters(context),
  execute: getAccountQuery
});
var get_account_query_default = getAccountQueryTool;

// src/plugins/core-queries-plugin/tools/queries/get-account-token-balances-query.ts
var getAccountTokenBalancesQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the token balances for a given Hedera account.

Parameters:
- ${accountDesc}
- tokenId (str, optional): The token ID to query for. If not provided, all token balances will be returned
${usageInstructions}
`;
};
var getAccountTokenBalancesQuery = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseAccountTokenBalancesParams(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const tokenBalances = await mirrornodeService.getAccountTokenBalances(
      normalisedParams.accountId,
      normalisedParams.tokenId
    );
    return { accountId: normalisedParams.accountId, tokenBalances };
  } catch (error) {
    console.error("Error getting account token balances", error);
    if (error instanceof Error) {
      return error.message;
    }
    return "Failed to get account token balances";
  }
};
var GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL = "get_account_token_balances_query_tool";
var tool11 = (context) => ({
  method: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,
  name: "Get Account Token Balances",
  description: getAccountTokenBalancesQueryPrompt(context),
  parameters: accountTokenBalancesQueryParameters(context),
  execute: getAccountTokenBalancesQuery
});
var get_account_token_balances_query_default = tool11;

// src/plugins/core-queries-plugin/tools/queries/get-topic-messages-query.ts
var getTopicMessagesQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the messages for a given Hedera topic.

Parameters:
- topicId (str, required): The topic ID to query
- startTime (datetime, optional): The start datetime to query. If set, the messages will be returned after this datetime
- endTime (datetime, optional): The end datetime to query. If set, the messages will be returned before this datetime
- limit (int, optional): The limit of messages to query. If set, the number of messages to return
${usageInstructions}
`;
};
var getTopicMessagesQueryParams = (params) => {
  return {
    topicId: params.topicId,
    lowerTimestamp: params.startTime ? `${Math.floor(new Date(params.startTime).getTime() / 1e3)}.000000000` : "",
    upperTimestamp: params.endTime ? `${Math.floor(new Date(params.endTime).getTime() / 1e3)}.000000000` : "",
    limit: params.limit || 100
  };
};
var convertMessagesFromBase64ToString = (messages) => {
  return messages.map((message) => {
    return {
      ...message,
      message: Buffer.from(message.message, "base64").toString("utf-8")
    };
  });
};
var getTopicMessagesQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const messages = await mirrornodeService.getTopicMessages(getTopicMessagesQueryParams(params));
    return {
      topicId: messages.topicId,
      messages: convertMessagesFromBase64ToString(messages.messages)
    };
  } catch (error) {
    console.error("Error getting topic messages", error);
    if (error instanceof Error) {
      return error.message;
    }
    return "Failed to get topic messages";
  }
};
var GET_TOPIC_MESSAGES_QUERY_TOOL = "get_topic_messages_query_tool";
var tool12 = (context) => ({
  method: GET_TOPIC_MESSAGES_QUERY_TOOL,
  name: "Get Topic Messages",
  description: getTopicMessagesQueryPrompt(context),
  parameters: topicMessagesQueryParameters(context),
  execute: getTopicMessagesQuery
});
var get_topic_messages_query_default = tool12;

// src/plugins/core-queries-plugin/index.ts
var coreQueriesPlugin = {
  name: "core-queries-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera Queries Service",
  tools: (context) => {
    return [
      get_hbar_balance_query_default(context),
      get_account_query_default(context),
      get_account_token_balances_query_default(context),
      get_topic_messages_query_default(context)
    ];
  }
};
var coreQueriesPluginToolNames = {
  GET_HBAR_BALANCE_QUERY_TOOL,
  GET_ACCOUNT_QUERY_TOOL,
  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,
  GET_TOPIC_MESSAGES_QUERY_TOOL
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AccountResolver,
  AgentMode,
  HederaAIToolkit,
  HederaLangchainToolkit,
  HederaMCPToolkit,
  PluginRegistry,
  PromptGenerator,
  ToolDiscovery,
  coreAccountPlugin,
  coreAccountPluginToolNames,
  coreConsensusPlugin,
  coreConsensusPluginToolNames,
  coreHTSPlugin,
  coreHTSPluginToolNames,
  coreQueriesPlugin,
  coreQueriesPluginToolNames,
  handleTransaction
});
//# sourceMappingURL=index.js.map