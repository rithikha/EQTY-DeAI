{"version":3,"sources":["../src/index.ts","../src/shared/api.ts","../src/shared/configuration.ts","../src/shared/plugin.ts","../src/shared/tool-discovery.ts","../src/shared/strategies/tx-mode-strategy.ts","../src/shared/utils/account-resolver.ts","../src/shared/utils/prompt-generator.ts","../src/langchain/tool.ts","../src/langchain/toolkit.ts","../src/modelcontextprotocol/toolkit.ts","../src/ai-sdk/tool.ts","../src/ai-sdk/toolkit.ts","../src/shared/hedera-utils/hedera-parameter-normaliser.ts","../src/shared/hedera-utils/decimals-utils.ts","../src/shared/parameter-schemas/hts.zod.ts","../src/shared/hedera-utils/hedera-builder.ts","../src/shared/hedera-utils/mirrornode/types.ts","../src/shared/hedera-utils/mirrornode/hedera-mirrornode-service-default-impl.ts","../src/shared/hedera-utils/mirrornode/hedera-mirrornode-utils.ts","../src/plugins/core-hts-plugin/tools/fungible-token/airdrop-fungible-token.ts","../src/plugins/core-hts-plugin/tools/fungible-token/create-fungible-token.ts","../src/plugins/core-hts-plugin/tools/fungible-token/mint-fungible-token.ts","../src/plugins/core-hts-plugin/tools/non-fungible-token/create-non-fungible-token.ts","../src/plugins/core-hts-plugin/tools/non-fungible-token/mint-non-fungible-token.ts","../src/plugins/core-hts-plugin/index.ts","../src/shared/parameter-schemas/has.zod.ts","../src/plugins/core-account-plugin/tools/account/transfer-hbar.ts","../src/plugins/core-account-plugin/index.ts","../src/shared/parameter-schemas/hcs.zod.ts","../src/plugins/core-consensus-plugin/tools/consensus/create-topic.ts","../src/plugins/core-consensus-plugin/tools/consensus/submit-topic-message.ts","../src/plugins/core-consensus-plugin/index.ts","../src/shared/parameter-schemas/account-query.zod.ts","../src/shared/hedera-utils/hbar-conversion-utils.ts","../src/plugins/core-queries-plugin/tools/queries/get-hbar-balance-query.ts","../src/plugins/core-queries-plugin/tools/queries/get-account-query.ts","../src/plugins/core-queries-plugin/tools/queries/get-account-token-balances-query.ts","../src/plugins/core-queries-plugin/tools/queries/get-topic-messages-query.ts","../src/plugins/core-queries-plugin/index.ts"],"sourcesContent":["export * from './shared/index';\nexport * from './langchain/index';\nexport * from './modelcontextprotocol/index';\nexport * from './ai-sdk/index';\nexport * from './plugins/index';\n","import { Client } from '@hashgraph/sdk';\n\nimport type { Context } from './configuration';\nimport { Tool } from './tools';\n\nclass HederaAgentAPI {\n  client: Client;\n\n  context: Context;\n\n  tools: Tool[];\n\n  constructor(client: Client, context?: Context, tools?: Tool[]) {\n    this.client = client;\n    if (!this.client.ledgerId) {\n      throw new Error('Client must be connected to a network');\n    }\n    this.context = context || {};\n    this.tools = tools || [];\n  }\n\n  async run(method: string, arg: unknown) {\n    const tool = this.tools.find(t => t.method === method);\n    if (tool) {\n      const output = JSON.stringify(await tool.execute(this.client, this.context, arg));\n      return output;\n    } else {\n      throw new Error('Invalid method ' + method);\n    }\n  }\n}\n\nexport default HederaAgentAPI;\n","import { IHederaMirrornodeService } from './hedera-utils/mirrornode/hedera-mirrornode-service.interface';\nimport { Plugin } from './plugin';\n\nexport enum AgentMode {\n  AUTONOMOUS = 'autonomous',\n  RETURN_BYTES = 'returnBytes',\n}\n\n// Context are settings that are applied to all requests made by the integration.\nexport type Context = {\n  // Account is a Connected Account ID. If set, the integration will\n  // make requests for this Account.\n  accountId?: string;\n  // Account Public Key is either passed in configuration or fetched based on the passed accountId\n  accountPublicKey?: string;\n\n  // defines if the agent executes the transactions or returns the raw transaction bytes\n  mode?: AgentMode;\n\n  // Mirrornode config\n  mirrornodeService?: IHederaMirrornodeService;\n};\n\nexport type Configuration = {\n  //if empty, all tools will be used.\n  tools?: string[];\n  //external plugins to load\n  plugins?: Plugin[];\n  context?: Context;\n};\n","import { Context } from './configuration';\nimport { Tool } from './tools';\n\nexport interface Plugin {\n  name: string;\n  version?: string;\n  description?: string;\n  tools: (context: Context) => Tool[];\n}\n\nexport class PluginRegistry {\n  private plugins = new Map<string, Plugin>();\n\n  register(plugin: Plugin): void {\n    if (this.plugins.has(plugin.name)) {\n      console.warn(`Plugin \"${plugin.name}\" is already registered. Overwriting.`);\n    }\n    this.plugins.set(plugin.name, plugin);\n  }\n\n  getPlugins(): Plugin[] {\n    return Array.from(this.plugins.values());\n  }\n\n  getTools(context: Context): Tool[] {\n    const pluginTools: Tool[] = [];\n\n    for (const plugin of this.plugins.values()) {\n      try {\n        const tools = plugin.tools(context);\n        pluginTools.push(...tools);\n      } catch (error) {\n        console.error(`Error loading tools from plugin \"${plugin.name}\":`, error);\n      }\n    }\n\n    return pluginTools;\n  }\n\n  clear(): void {\n    this.plugins.clear();\n  }\n}\n","import { Context, Configuration } from './configuration';\nimport { Tool } from './tools';\nimport { Plugin, PluginRegistry } from './plugin';\n\nexport class ToolDiscovery {\n  private pluginRegistry = new PluginRegistry();\n\n  constructor(plugins: Plugin[] = []) {\n    plugins.forEach(plugin => this.pluginRegistry.register(plugin));\n  }\n\n  getAllTools(context: Context, configuration?: Configuration): Tool[] {\n    // Get plugin tools\n    const pluginTools = this.pluginRegistry.getTools(context);\n\n    // Merge all tools (core tools take precedence in case of name conflicts)\n    const allTools: any = [];\n    const allToolNames = new Set<string>();\n\n    // Add plugin tools that don't conflict with core tools\n    pluginTools.forEach(pluginTool => {\n      if (!allToolNames.has(pluginTool.method)) {\n        allTools.push(pluginTool);\n        allToolNames.add(pluginTool.method);\n      } else {\n        console.warn(\n          `Plugin tool \"${pluginTool.method}\" conflicts with core tool. Using core tool.`,\n        );\n      }\n    });\n\n    // Apply tool filtering if specified in configuration\n    if (configuration?.tools && configuration.tools.length > 0) {\n      return allTools.filter((tool: any) => configuration.tools!.includes(tool.method));\n    }\n\n    return allTools;\n  }\n\n  static createFromConfiguration(configuration: Configuration): ToolDiscovery {\n    return new ToolDiscovery(configuration.plugins || []);\n  }\n}\n","import { AccountId, Client, Transaction, TransactionId } from '@hashgraph/sdk';\nimport { AgentMode, Context } from '@/shared/configuration';\n\ninterface TxModeStrategy {\n  handle<T extends Transaction>(tx: T, client: Client, context: Context): Promise<unknown>;\n}\n\nclass ExecuteStrategy implements TxModeStrategy {\n  async handle(tx: Transaction, client: Client) {\n    const submit = await tx.execute(client);\n    const receipt = await submit.getReceipt(client);\n    return {\n      status: receipt.status._code,\n      accountId: receipt.accountId,\n      tokenId: receipt.tokenId,\n      transactionId: tx.transactionId,\n      topicId: receipt.topicId,\n      contractId: receipt.contractId,\n      receipt: receipt,\n    };\n  }\n}\n\nclass ReturnBytesStrategy implements TxModeStrategy {\n  async handle(tx: Transaction, _client: Client, context: Context) {\n    if (!context.accountId) throw new Error('…');\n    const id = TransactionId.generate(context.accountId);\n    tx.setNodeAccountIds([new AccountId(4), new AccountId(5)])\n      .setTransactionId(id)\n      .freeze();\n    return { bytes: tx.toBytes() };\n  }\n}\n\nconst getStrategyFromContext = (context: Context) => {\n  if (context.mode === AgentMode.RETURN_BYTES) {\n    return new ReturnBytesStrategy();\n  }\n  return new ExecuteStrategy();\n};\n\nexport const handleTransaction = async (tx: Transaction, client: Client, context: Context) => {\n  const strategy = getStrategyFromContext(context);\n  return await strategy.handle(tx, client, context);\n};\n","import { Client } from '@hashgraph/sdk';\nimport { Context, AgentMode } from '@/shared/configuration';\n\nexport class AccountResolver {\n  /**\n   * Gets the default account based on the agent mode and context.\n   * In RETURN_BYTES mode, prefers context.accountId (user's account).\n   * In AUTONOMOUS mode or when no context account, uses operator account.\n   */\n  static getDefaultAccount(context: Context, client: Client): string {\n    // In returnBytes mode, prefer context.accountId (user's account)\n    if (context.mode === AgentMode.RETURN_BYTES && context.accountId) {\n      return context.accountId;\n    }\n\n    // In autonomous mode or when no context account, use operator\n    const operatorAccount = client.operatorAccountId?.toString();\n    if (!operatorAccount) {\n      throw new Error('No account available: neither context.accountId nor operator account');\n    }\n\n    return operatorAccount;\n  }\n\n  /**\n   * Resolves an account ID, using the provided account or falling back to the default.\n   */\n  static resolveAccount(\n    providedAccount: string | undefined,\n    context: Context,\n    client: Client,\n  ): string {\n    return providedAccount || this.getDefaultAccount(context, client);\n  }\n\n  /**\n   * Gets a description of which account will be used as default for prompts.\n   */\n  static getDefaultAccountDescription(context: Context): string {\n    if (context.mode === AgentMode.RETURN_BYTES && context.accountId) {\n      return `user account (${context.accountId})`;\n    }\n    return 'operator account';\n  }\n}\n","import { Context, AgentMode } from '@/shared/configuration';\nimport { AccountResolver } from './account-resolver';\n\nexport class PromptGenerator {\n  /**\n   * Generates a consistent context snippet for tool prompts.\n   */\n  static getContextSnippet(context: Context): string {\n    const lines = ['Context:'];\n\n    if (context.mode === AgentMode.RETURN_BYTES) {\n      lines.push(`- Mode: Return Bytes (preparing transactions for user signing)`);\n      if (context.accountId) {\n        lines.push(`- User Account: ${context.accountId} (default for transaction parameters)`);\n        lines.push(`- When no account is specified, ${context.accountId} will be used`);\n      } else {\n        lines.push(`- User Account: Not specified`);\n        lines.push(`- When no account is specified, the operator account will be used`);\n      }\n    } else if (context.mode === AgentMode.AUTONOMOUS) {\n      lines.push(`- Mode: Autonomous (agent executes transactions directly)`);\n      if (context.accountId) {\n        lines.push(`- User Account: ${context.accountId}`);\n      }\n      lines.push(`- When no account is specified, the operator account will be used`);\n    } else {\n      lines.push(`- Mode: ${context.mode || 'Not specified'}`);\n      if (context.accountId) {\n        lines.push(`- User Account: ${context.accountId}`);\n      }\n      lines.push(`- Default account will be determined at execution time`);\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Generates a consistent description for optional account parameters.\n   */\n  static getAccountParameterDescription(\n    paramName: string,\n    context: Context,\n    isRequired: boolean = false,\n  ): string {\n    if (isRequired) {\n      return `${paramName} (str, required): The Hedera account ID`;\n    }\n\n    const defaultAccountDesc = AccountResolver.getDefaultAccountDescription(context);\n    return `${paramName} (str, optional): The Hedera account ID. If not provided, defaults to the ${defaultAccountDesc}`;\n  }\n\n  /**\n   * Generates consistent parameter usage instructions.\n   */\n  static getParameterUsageInstructions(): string {\n    return `\nImportant:\n- Only include optional parameters if explicitly provided by the user\n- Do not generate placeholder values for optional fields\n- Leave optional parameters undefined if not specified by the user`;\n  }\n}\n","import { z } from 'zod';\nimport { StructuredTool } from '@langchain/core/tools';\nimport { CallbackManagerForToolRun } from '@langchain/core/callbacks/manager';\nimport { RunnableConfig } from '@langchain/core/runnables';\nimport HederaAgentKitAPI from '@/shared/api';\n\nclass HederaAgentKitTool extends StructuredTool {\n  hederaAPI: HederaAgentKitAPI;\n\n  method: string;\n\n  name: string;\n\n  description: string;\n\n  schema: z.ZodObject<any, any>;\n\n  constructor(\n    HederaAgentKitAPI: HederaAgentKitAPI,\n    method: string,\n    description: string,\n    schema: z.ZodObject<any, any>,\n  ) {\n    super();\n\n    this.hederaAPI = HederaAgentKitAPI;\n    this.method = method;\n    this.name = method;\n    this.description = description;\n    this.schema = schema;\n  }\n\n  _call(\n    arg: z.output<typeof this.schema>,\n    _runManager?: CallbackManagerForToolRun,\n    _parentConfig?: RunnableConfig,\n  ): Promise<any> {\n    return this.hederaAPI.run(this.method, arg);\n  }\n}\n\nexport default HederaAgentKitTool;\n","import { BaseToolkit } from '@langchain/core/tools';\nimport HederaAgentKitTool from '@/langchain/tool';\nimport HederaAgentKitAPI from '@/shared/api';\nimport { type Configuration } from '@/shared/configuration';\nimport { ToolDiscovery } from '@/shared/tool-discovery';\nimport { Client } from '@hashgraph/sdk';\n\nclass HederaLangchainToolkit implements BaseToolkit {\n  private _hederaAgentKit: HederaAgentKitAPI;\n\n  tools: HederaAgentKitTool[];\n\n  constructor({ client, configuration }: { client: Client; configuration: Configuration }) {\n    const context = configuration.context || {};\n    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);\n    const allTools = toolDiscovery.getAllTools(context, configuration);\n\n    this._hederaAgentKit = new HederaAgentKitAPI(client, configuration.context, allTools);\n    this.tools = allTools.map(\n      tool =>\n        new HederaAgentKitTool(\n          this._hederaAgentKit,\n          tool.method,\n          tool.description,\n          tool.parameters,\n        ),\n    );\n  }\n\n  getTools(): HederaAgentKitTool[] {\n    return this.tools;\n  }\n}\n\nexport default HederaLangchainToolkit;\n","import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { Client } from '@hashgraph/sdk';\nimport { Configuration } from '@/shared/configuration';\nimport HederaAgentKitAPI from '@/shared/api';\nimport { ToolDiscovery } from '@/shared/tool-discovery';\nimport { RequestHandlerExtra } from '@modelcontextprotocol/sdk/shared/protocol.js';\n\nclass HederaMCPToolkit extends McpServer {\n  private _hederaAgentKit: HederaAgentKitAPI;\n\n  constructor({ client, configuration }: { client: Client; configuration: Configuration }) {\n    super({\n      name: 'Hedera Agent Kit',\n      version: '0.1.0',\n      configuration: {\n        ...configuration,\n        context: {\n          ...configuration.context,\n          mode: 'modelcontextprotocol',\n        },\n      },\n    });\n\n    const context = configuration.context || {};\n    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);\n    const allTools = toolDiscovery.getAllTools(context, configuration);\n    this._hederaAgentKit = new HederaAgentKitAPI(client, configuration.context, allTools);\n\n    allTools.map(tool => {\n      this.tool(\n        tool.method,\n        tool.description,\n        tool.parameters.shape,\n        async (arg: any, _extra: RequestHandlerExtra<any, any>) => {\n          const result = await this._hederaAgentKit.run(tool.method, arg);\n          return {\n            content: [\n              {\n                type: 'text' as const,\n                text: String(result),\n              },\n            ],\n          };\n        },\n      );\n    });\n  }\n}\n\nexport default HederaMCPToolkit;\n","import HederaAgentAPI from '@/shared/api';\nimport { tool } from 'ai';\nimport z from 'zod';\n\nexport default function HederaAgentKitTool(\n  hederaAPI: HederaAgentAPI,\n  method: string,\n  description: string,\n  schema: z.ZodObject<any, any>,\n) {\n  return tool({\n    description: description,\n    parameters: schema,\n    execute: (arg: z.output<typeof schema>) => {\n      return hederaAPI.run(method, arg);\n    },\n  });\n}\n","import HederaAgentAPI from '../shared/api';\nimport { type Configuration } from '../shared/configuration';\nimport { ToolDiscovery } from '../shared/tool-discovery';\nimport type { Tool, LanguageModelV1Middleware } from 'ai';\nimport { Client } from '@hashgraph/sdk';\nimport HederaAgentKitTool from './tool';\n\nclass HederaAIToolkit {\n  private _hedera: HederaAgentAPI;\n\n  tools: { [key: string]: Tool };\n\n  constructor({ client, configuration }: { client: Client; configuration: Configuration }) {\n    const context = configuration.context || {};\n    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);\n    const allTools = toolDiscovery.getAllTools(context, configuration);\n    this._hedera = new HederaAgentAPI(client, configuration.context, allTools);\n    this.tools = {};\n\n    allTools.forEach(tool => {\n      this.tools[tool.method] = HederaAgentKitTool(\n        this._hedera,\n        tool.method,\n        tool.description,\n        tool.parameters,\n      );\n    });\n  }\n\n  middleware(): LanguageModelV1Middleware {\n    return {\n      wrapGenerate: async ({ doGenerate }) => {\n        return doGenerate();\n      },\n      wrapStream: async ({ doStream }) => {\n        // Pre-processing can be added here if needed\n        return doStream();\n      },\n    };\n  }\n  getTools(): { [key: string]: Tool } {\n    return this.tools;\n  }\n}\n\nexport default HederaAIToolkit;\n","// optional to use methods in here\n\nimport {\n  airdropFungibleTokenParameters,\n  createFungibleTokenParameters,\n  createFungibleTokenParametersNormalised,\n  createNonFungibleTokenParameters,\n  createNonFungibleTokenParametersNormalised,\n  mintFungibleTokenParameters,\n  mintNonFungibleTokenParameters,\n} from '@/shared/parameter-schemas/hts.zod';\nimport { transferHbarParameters } from '@/shared/parameter-schemas/has.zod';\nimport {\n  createTopicParameters,\n  createTopicParametersNormalised,\n} from '@/shared/parameter-schemas/hcs.zod';\nimport { Client, Hbar, PublicKey, TokenSupplyType, TokenType } from '@hashgraph/sdk';\nimport { Context } from '@/shared/configuration';\nimport z from 'zod';\nimport {\n  accountBalanceQueryParameters,\n  accountTokenBalancesQueryParameters,\n} from '@/shared/parameter-schemas/account-query.zod';\nimport { IHederaMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-service.interface';\nimport { toBaseUnit } from '@/shared/hedera-utils/decimals-utils';\nimport Long from 'long';\nimport { TokenTransferMinimalParams, TransferHbarInput } from '@/shared/hedera-utils/types';\nimport { AccountResolver } from '@/shared/utils/account-resolver';\n\nexport default class HederaParameterNormaliser {\n  static async normaliseCreateFungibleTokenParams(\n    params: z.infer<ReturnType<typeof createFungibleTokenParameters>>,\n    context: Context,\n    client: Client,\n    mirrorNode: IHederaMirrornodeService,\n  ) {\n    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);\n\n    const normalized: z.infer<ReturnType<typeof createFungibleTokenParametersNormalised>> = {\n      ...params,\n      supplyType: TokenSupplyType.Finite, // defaults to finite supply\n      autoRenewAccountId: defaultAccountId,\n    };\n\n    const treasuryAccountId = params.treasuryAccountId ?? defaultAccountId;\n\n    if (!treasuryAccountId) {\n      throw new Error('Must include treasury account ID');\n    }\n\n    const supplyTypeString = params.supplyType ?? 'infinite';\n    const supplyType =\n      supplyTypeString === 'finite' ? TokenSupplyType.Finite : TokenSupplyType.Infinite;\n    const decimals = params.decimals ?? 0;\n    const initialSupply = toBaseUnit(params.initialSupply ?? 0, decimals);\n\n    let maxSupply: number | undefined = undefined;\n    if (supplyTypeString === 'finite') {\n      if (!params.maxSupply) {\n        throw new Error('Must include max supply for finite supply type');\n      }\n      maxSupply = toBaseUnit(params.maxSupply, decimals);\n\n      if (initialSupply > maxSupply) {\n        throw new Error(\n          `Initial supply (${initialSupply}) cannot exceed max supply (${maxSupply})`,\n        );\n      }\n    }\n\n    const publicKey =\n      (await mirrorNode.getAccount(defaultAccountId).then(r => r.accountPublicKey)) ??\n      client.operatorPublicKey?.toStringDer();\n\n    if (params.isSupplyKey === true) {\n      normalized.supplyKey = PublicKey.fromString(publicKey);\n    }\n\n    const autoRenewAccountId = defaultAccountId;\n\n    return {\n      ...normalized,\n      treasuryAccountId,\n      supplyType,\n      maxSupply,\n      decimals,\n      initialSupply,\n      autoRenewAccountId,\n    };\n  }\n\n  static async normaliseCreateNonFungibleTokenParams(\n    params: z.infer<ReturnType<typeof createNonFungibleTokenParameters>>,\n    context: Context,\n    client: Client,\n    mirrorNode: IHederaMirrornodeService,\n  ) {\n    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);\n\n    const treasuryAccountId = params.treasuryAccountId || defaultAccountId;\n    if (!treasuryAccountId) throw new Error('Must include treasury account ID');\n\n    const publicKey =\n      (await mirrorNode.getAccount(defaultAccountId).then(r => r.accountPublicKey)) ??\n      client.operatorPublicKey?.toStringDer();\n\n    const maxSupply = params.maxSupply ?? 100;\n    const normalized: z.infer<ReturnType<typeof createNonFungibleTokenParametersNormalised>> = {\n      ...params,\n      treasuryAccountId,\n      maxSupply,\n      supplyKey: PublicKey.fromString(publicKey), // the supply key is mandatory in the case of NFT\n      supplyType: TokenSupplyType.Finite, // NFTs supply must be finite\n      autoRenewAccountId: defaultAccountId,\n      tokenType: TokenType.NonFungibleUnique,\n    };\n\n    return normalized;\n  }\n\n  static normaliseTransferHbar(\n    params: z.infer<ReturnType<typeof transferHbarParameters>>,\n    context: Context,\n    client: Client,\n  ) {\n    const sourceAccountId = AccountResolver.resolveAccount(params.sourceAccountId, context, client);\n\n    const hbarTransfers: TransferHbarInput[] = [];\n\n    let totalTinybars = Long.ZERO;\n\n    for (const transfer of params.transfers) {\n      const amount = new Hbar(transfer.amount);\n\n      if (amount.isNegative() || amount.toTinybars().equals(Long.ZERO)) {\n        throw new Error(`Invalid transfer amount: ${transfer.amount}`);\n      }\n\n      totalTinybars = totalTinybars.add(amount.toTinybars());\n\n      hbarTransfers.push({\n        accountId: transfer.accountId,\n        amount,\n      });\n    }\n\n    hbarTransfers.push({\n      accountId: sourceAccountId,\n      amount: Hbar.fromTinybars(totalTinybars.negate()),\n    });\n\n    return {\n      hbarTransfers,\n      transactionMemo: params.transactionMemo,\n    };\n  }\n\n  static async normaliseAirdropFungibleTokenParams(\n    params: z.infer<ReturnType<typeof airdropFungibleTokenParameters>>,\n    context: Context,\n    client: Client,\n    mirrorNode: IHederaMirrornodeService,\n  ) {\n    const sourceAccountId = AccountResolver.resolveAccount(params.sourceAccountId, context, client);\n\n    const tokenDetails = await mirrorNode.getTokenDetails(params.tokenId);\n    const tokenDecimals = parseInt(tokenDetails.decimals, 10);\n\n    const tokenTransfers: TokenTransferMinimalParams[] = [];\n    let totalAmount = Long.ZERO;\n\n    for (const recipient of params.recipients) {\n      const amountRaw = Number(recipient.amount);\n\n      if (amountRaw <= 0) {\n        throw new Error(`Invalid recipient amount: ${recipient.amount}`);\n      }\n\n      const amount = Long.fromString(toBaseUnit(amountRaw, tokenDecimals).toString());\n\n      totalAmount = totalAmount.add(amount);\n\n      tokenTransfers.push({\n        tokenId: params.tokenId,\n        accountId: recipient.accountId,\n        amount,\n      });\n    }\n\n    // Sender negative total\n    tokenTransfers.push({\n      tokenId: params.tokenId,\n      accountId: sourceAccountId,\n      amount: totalAmount.negate(),\n    });\n\n    return {\n      tokenTransfers,\n    };\n  }\n\n  static async normaliseCreateTopicParams(\n    params: z.infer<ReturnType<typeof createTopicParameters>>,\n    context: Context,\n    client: Client,\n    mirrorNode: IHederaMirrornodeService,\n  ) {\n    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);\n    const normalised: z.infer<ReturnType<typeof createTopicParametersNormalised>> = {\n      ...params,\n      autoRenewAccountId: defaultAccountId,\n    };\n\n    if (params.isSubmitKey) {\n      const publicKey =\n        (await mirrorNode.getAccount(defaultAccountId).then(r => r.accountPublicKey)) ??\n        client.operatorPublicKey?.toStringDer();\n      if (!publicKey) {\n        throw new Error('Could not determine default account ID for submit key');\n      }\n      normalised.submitKey = PublicKey.fromString(publicKey);\n    }\n\n    return normalised;\n  }\n\n  static normaliseHbarBalanceParams(\n    params: z.infer<ReturnType<typeof accountBalanceQueryParameters>>,\n    context: Context,\n    client: Client,\n  ) {\n    const accountId = AccountResolver.resolveAccount(params.accountId, context, client);\n    return {\n      ...params,\n      accountId,\n    };\n  }\n\n  static normaliseAccountTokenBalancesParams(\n    params: z.infer<ReturnType<typeof accountTokenBalancesQueryParameters>>,\n    context: Context,\n    client: Client,\n  ) {\n    const accountId = AccountResolver.resolveAccount(params.accountId, context, client);\n    return {\n      ...params,\n      accountId,\n    };\n  }\n\n  static async normaliseMintFungibleTokenParams(\n    params: z.infer<ReturnType<typeof mintFungibleTokenParameters>>,\n    context: Context,\n    mirrorNode: IHederaMirrornodeService,\n  ) {\n    const decimals =\n      (await mirrorNode.getTokenDetails(params.tokenId).then(r => Number(r.decimals))) ?? 0;\n    const baseAmount = toBaseUnit(params.amount, decimals);\n    return {\n      tokenId: params.tokenId,\n      amount: baseAmount,\n    };\n  }\n\n  static normaliseMintNonFungibleTokenParams(\n    params: z.infer<ReturnType<typeof mintNonFungibleTokenParameters>>,\n    _context: Context,\n  ) {\n    const encoder = new TextEncoder();\n    const metadata = params.uris.map(uri => encoder.encode(uri));\n    return {\n      ...params,\n      metadata: metadata,\n    };\n  }\n}\n","/**\n * Converts a token amount to base units (smallest denomination).\n * Example: toBaseUnit(1.5, 8) => 150000000\n *\n * @param amount - The human-readable token amount.\n * @param decimals - The number of decimals the token uses.\n * @returns The amount in base units (as integer).\n */\nexport function toBaseUnit(amount: number, decimals: number): number {\n  return Math.floor(amount * 10 ** decimals);\n}\n\n/**\n * Converts a base unit amount to a human-readable value.\n * Example: toDisplayUnit(150000000, 8) => 1.5\n *\n * @param baseAmount - The amount in base units (integer).\n * @param decimals - The number of decimals the token uses.\n * @returns The human-readable token amount.\n */\nexport function toDisplayUnit(baseAmount: number, decimals: number): number {\n  return baseAmount / 10 ** decimals;\n}\n","import { Context } from '@/shared/configuration';\nimport { z } from 'zod';\nimport { PublicKey, TokenSupplyType, TokenType } from '@hashgraph/sdk';\nimport { TokenTransferMinimalParams } from '@/shared/hedera-utils/types';\n\nexport const createFungibleTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenName: z.string().describe('The name of the token.'),\n    tokenSymbol: z.string().describe('The symbol of the token.'),\n    initialSupply: z.number().int().default(0).describe('The initial supply of the token.'),\n    supplyType: z.enum(['finite', 'infinite']).optional().describe('Supply type of the token.'),\n    maxSupply: z.number().int().optional().describe('The maximum supply of the token.'),\n    decimals: z.number().int().optional().default(0).describe('The number of decimals.'),\n    treasuryAccountId: z.string().optional().describe('The treasury account of the token.'),\n    isSupplyKey: z\n      .boolean()\n      .optional()\n      .describe('Determines if the token supply key should be set.'),\n  });\n\nexport const createFungibleTokenParametersNormalised = (_context: Context = {}) =>\n  createFungibleTokenParameters(_context).extend({\n    autoRenewAccountId: z\n      .string()\n      .describe(\n        'The auto renew account for the token. If not provided, defaults to the operator account.',\n      ),\n    supplyKey: z\n      .custom<PublicKey>()\n      .optional()\n      .describe('The supply key. If not provided, defaults to the operator’s public key.'),\n    supplyType: z.custom<TokenSupplyType>().describe('Supply type of the token.'),\n  });\n\nexport const createNonFungibleTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenName: z.string().describe('The name of the token.'),\n    tokenSymbol: z.string().describe('The symbol of the token.'),\n    maxSupply: z\n      .number()\n      .int()\n      .optional()\n      .default(100)\n      .describe('The maximum supply of the token.'),\n    treasuryAccountId: z.string().optional().describe('The treasury account of the token.'),\n  });\n\nexport const createNonFungibleTokenParametersNormalised = (_context: Context = {}) =>\n  createNonFungibleTokenParameters(_context).extend({\n    autoRenewAccountId: z\n      .string()\n      .describe(\n        'The auto renew account for the token. If not provided, defaults to the operator account.',\n      ),\n    supplyKey: z\n      .custom<PublicKey>()\n      .describe('The supply key. If not provided, defaults to the operator’s public key.'),\n    supplyType: z\n      .custom<TokenSupplyType>()\n      .default(TokenSupplyType.Finite)\n      .describe('Supply type of the token - must be finite for NFT.'),\n    tokenType: z\n      .custom<TokenType>()\n      .default(TokenType.NonFungibleUnique)\n      .describe('Token type of the token - must be non-fungible unique for NFT.'),\n  });\n\nconst AirdropRecipientSchema = z.object({\n  accountId: z.string().describe('Recipient account ID (e.g., \"0.0.xxxx\").'),\n  amount: z.union([z.number(), z.string()]).describe('Amount in base unit.'),\n});\n\nexport const airdropFungibleTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenId: z.string().describe('The id of the token.'),\n    amount: z.number().describe('The amount of tokens to airdrop.'),\n    sourceAccountId: z.string().optional().describe('The account to airdrop the token from.'),\n    recipients: z\n      .array(AirdropRecipientSchema)\n      .min(1)\n      .describe('Array of recipient objects, each with accountId and amount.'),\n  });\n\nexport const airdropFungibleTokenParametersNormalised = () =>\n  z.object({\n    tokenTransfers: z\n      .custom<TokenTransferMinimalParams[]>()\n      .describe('Array of TokenTransfer objects constructed from the original recipients.'),\n  });\n\nexport const mintFungibleTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenId: z.string().describe('The id of the token.'),\n    amount: z.number().describe('The amount of tokens to mint.'),\n  });\n\nexport const mintFungibleTokenParametersNormalised = (_context: Context = {}) =>\n  mintFungibleTokenParameters(_context).extend({});\n\nexport const mintNonFungibleTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenId: z.string().describe('The id of the NFT class.'),\n    uris: z.array(z.string().max(100)).max(10).describe('An array of URIs hosting NFT metadata.'),\n  });\n\nexport const mintNonFungibleTokenParametersNormalised = (_context: Context = {}) =>\n  mintNonFungibleTokenParameters(_context).extend({});\n","import {\n  TokenAirdropTransaction,\n  TokenCreateTransaction,\n  TopicCreateTransaction,\n  TopicMessageSubmitTransaction,\n  TransferTransaction,\n  TokenMintTransaction,\n} from '@hashgraph/sdk';\nimport {\n  airdropFungibleTokenParametersNormalised,\n  createFungibleTokenParametersNormalised,\n  createNonFungibleTokenParametersNormalised,\n  mintFungibleTokenParametersNormalised,\n  mintNonFungibleTokenParametersNormalised,\n} from '@/shared/parameter-schemas/hts.zod';\nimport z from 'zod';\nimport { transferHbarParametersNormalised } from '@/shared/parameter-schemas/has.zod';\nimport {\n  createTopicParametersNormalised,\n  submitTopicMessageParametersNormalised,\n} from '@/shared/parameter-schemas/hcs.zod';\n\nexport default class HederaBuilder {\n  static createFungibleToken(\n    params: z.infer<ReturnType<typeof createFungibleTokenParametersNormalised>>,\n  ) {\n    return new TokenCreateTransaction(params);\n  }\n\n  static createNonFungibleToken(\n    params: z.infer<ReturnType<typeof createNonFungibleTokenParametersNormalised>>,\n  ) {\n    return new TokenCreateTransaction(params);\n  }\n\n  static transferHbar(params: z.infer<ReturnType<typeof transferHbarParametersNormalised>>) {\n    return new TransferTransaction(params);\n  }\n\n  static airdropFungibleToken(\n    params: z.infer<ReturnType<typeof airdropFungibleTokenParametersNormalised>>,\n  ) {\n    return new TokenAirdropTransaction(params as any);\n  }\n\n  static createTopic(params: z.infer<ReturnType<typeof createTopicParametersNormalised>>) {\n    return new TopicCreateTransaction(params);\n  }\n\n  static submitTopicMessage(\n    params: z.infer<ReturnType<typeof submitTopicMessageParametersNormalised>>,\n  ) {\n    return new TopicMessageSubmitTransaction(params);\n  }\n\n  static mintFungibleToken(\n    params: z.infer<ReturnType<typeof mintFungibleTokenParametersNormalised>>,\n  ) {\n    return new TokenMintTransaction(params);\n  }\n\n  static mintNonFungibleToken(\n    params: z.infer<ReturnType<typeof mintNonFungibleTokenParametersNormalised>>,\n  ) {\n    return new TokenMintTransaction(params);\n  }\n}\n","import { LedgerId, TokenType } from '@hashgraph/sdk';\nimport BigNumber from 'bignumber.js';\n\nexport const LedgerIdToBaseUrl: Map<string, string> = new Map([\n  [LedgerId.MAINNET.toString(), 'https://mainnet-public.mirrornode.hedera.com/api/v1'],\n  [LedgerId.TESTNET.toString(), 'https://testnet.mirrornode.hedera.com/api/v1'],\n]);\n\nexport type AccountTokenBalancesQueryParams = {\n  accountId: string;\n  tokenId?: string;\n};\n\nexport type TopicMessagesQueryParams = {\n  topicId: string;\n  lowerTimestamp: string;\n  upperTimestamp: string;\n  limit: number;\n};\n\nexport type TopicMessage = {\n  topicId: string;\n  message: string;\n  timestamp: string;\n};\n\nexport type TopicMessagesResponse = {\n  topicId: string;\n  messages: TopicMessage[];\n};\n\nexport type TokenBalance = {\n  account: string;\n  balance: number;\n  decimals: number;\n};\nexport type TokenBalancesResponse = {\n  tokens: TokenBalance[];\n};\nexport type AccountResponse = {\n  accountId: string;\n  accountPublicKey: string;\n  balance: AccountBalanceResponse;\n};\n\nexport type AccountAPIResponse = {\n  accountId: string;\n  key: {\n    key: string;\n    _type: KeyEncryptionType;\n  };\n  balance: AccountBalanceResponse;\n};\n\nexport type AccountBalanceResponse = {\n  balance: BigNumber;\n  timestamp: string;\n  tokens: TokenBalance[];\n};\n\nexport type TopicMessagesAPIResponse = {\n  messages: TopicMessage[];\n  links: {\n    next: string | null;\n  };\n};\n\nexport type KeyEncryptionType = 'ED25519' | 'ECDSA_SECP256K1';\n\nexport type TokenDetails = {\n  decimals: string;\n  name: string;\n  symbol: string;\n  maxSupply: number;\n  type: TokenType;\n};\n","import { LedgerId } from '@hashgraph/sdk';\nimport { IHederaMirrornodeService } from './hedera-mirrornode-service.interface';\nimport {\n  AccountAPIResponse,\n  AccountResponse,\n  LedgerIdToBaseUrl,\n  TokenBalancesResponse,\n  TokenDetails,\n  TopicMessage,\n  TopicMessagesAPIResponse,\n  TopicMessagesQueryParams,\n  TopicMessagesResponse,\n} from './types';\nimport BigNumber from 'bignumber.js';\n\nexport class HederaMirrornodeServiceDefaultImpl implements IHederaMirrornodeService {\n  private readonly baseUrl: string;\n\n  constructor(private readonly ledgerId: LedgerId) {\n    if (!LedgerIdToBaseUrl.has(ledgerId.toString())) {\n      throw new Error(`Network type ${ledgerId} not supported`);\n    }\n    this.baseUrl = LedgerIdToBaseUrl.get(ledgerId.toString())!;\n  }\n\n  async getAccount(accountId: string): Promise<AccountResponse> {\n    const url = `${this.baseUrl}/accounts/${accountId}`;\n    const response = await fetch(url);\n    const data: AccountAPIResponse = await response.json();\n    return {\n      accountId: data.accountId,\n      accountPublicKey: data.key.key,\n      balance: data.balance,\n    };\n  }\n\n  async getAccountHBarBalance(accountId: string): Promise<BigNumber> {\n    const account = await this.getAccount(accountId);\n    return new BigNumber(account.balance.balance);\n  }\n\n  async getAccountTokenBalances(\n    accountId: string,\n    tokenId?: string,\n  ): Promise<TokenBalancesResponse> {\n    const tokenIdParam = tokenId ? `&token.id=${tokenId}` : '';\n    const url = `${this.baseUrl}/accounts/${accountId}/tokens?${tokenIdParam}`;\n    const response = await fetch(url);\n    return await response.json();\n  }\n\n  async getTopicMessages(queryParams: TopicMessagesQueryParams): Promise<TopicMessagesResponse> {\n    const lowerThreshold = queryParams.lowerTimestamp\n      ? `&timestamp=gte:${queryParams.lowerTimestamp}`\n      : '';\n    const upperThreshold = queryParams.upperTimestamp\n      ? `&timestamp=lte:${queryParams.upperTimestamp}`\n      : '';\n    const baseParams = `&order=desc&limit=100`;\n    let url: string | null =\n      `${this.baseUrl}/topics/${queryParams.topicId}/messages?${lowerThreshold}${upperThreshold}${baseParams}`;\n    const arrayOfMessages: TopicMessage[] = [];\n    let fetchedMessages = 0;\n    try {\n      while (url) {\n        // Results are paginated\n\n        fetchedMessages += 1;\n        const response = await fetch(url);\n\n        if (!response.ok) {\n          throw new Error(\n            `HTTP error! status: ${response.status}. Message: ${response.statusText}`,\n          );\n        }\n\n        const data: TopicMessagesAPIResponse = await response.json();\n\n        arrayOfMessages.push(...data.messages);\n        if (fetchedMessages >= 100) {\n          break;\n        }\n\n        // Update URL for pagination.\n        // This endpoint does not return a full path to the next page, it has to be built first\n        url = data.links.next ? this.baseUrl + data.links.next : null;\n      }\n    } catch (error) {\n      console.error('Failed to fetch topic messages. Error:', error);\n      throw error;\n    }\n    return {\n      topicId: queryParams.topicId,\n      messages: arrayOfMessages.slice(0, queryParams.limit),\n    };\n  }\n\n  async getTokenDetails(tokenId: string): Promise<TokenDetails> {\n    const url = `${this.baseUrl}/tokens/${tokenId}`;\n    const response = await fetch(url);\n    return await response.json();\n  }\n}\n","import { LedgerId } from '@hashgraph/sdk';\nimport { HederaMirrornodeServiceDefaultImpl } from './hedera-mirrornode-service-default-impl';\nimport { IHederaMirrornodeService } from './hedera-mirrornode-service.interface';\n\nexport const getMirrornodeService = (\n  mirrornodeService: IHederaMirrornodeService | undefined,\n  ledgerId: LedgerId,\n) => {\n  if (mirrornodeService) {\n    return mirrornodeService;\n  }\n  return new HederaMirrornodeServiceDefaultImpl(ledgerId);\n};\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client } from '@hashgraph/sdk';\nimport { handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport { airdropFungibleTokenParameters } from '@/shared/parameter-schemas/hts.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst airdropFungibleTokenPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(\n    'sourceAccountId',\n    context,\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will airdrop a fungible token on Hedera.\n\nParameters:\n- tokenId (str, required): The id of the token\n- ${sourceAccountDesc}\n- recipients (array, required): A list of recipient objects, each containing:\n  - accountId (string): The recipient's account ID (e.g., \"0.0.1234\")\n  - amount (number or string): The amount of tokens to send to that recipient (in base units)\n- transactionMemo (str, optional): Optional memo for the transaction\n${usageInstructions}\n`;\n};\n\nconst airdropFungibleToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof airdropFungibleTokenParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const normalisedParams = await HederaParameterNormaliser.normaliseAirdropFungibleTokenParams(\n      params,\n      context,\n      client,\n      mirrornodeService,\n    );\n    const tx = HederaBuilder.airdropFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Failed to airdrop fungible token';\n  }\n};\n\nexport const AIRDROP_FUNGIBLE_TOKEN_TOOL = 'airdrop_fungible_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: AIRDROP_FUNGIBLE_TOKEN_TOOL,\n  name: 'Airdrop Fungible Token',\n  description: airdropFungibleTokenPrompt(context),\n  parameters: airdropFungibleTokenParameters(context),\n  execute: airdropFungibleToken,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client } from '@hashgraph/sdk';\nimport { handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport { createFungibleTokenParameters } from '@/shared/parameter-schemas/hts.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst createFungibleTokenPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const treasuryAccountDesc = PromptGenerator.getAccountParameterDescription(\n    'treasuryAccountId',\n    context,\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool creates a fungible token on Hedera.\n\nParameters:\n- tokenName (str, required): The name of the token\n- tokenSymbol (str, optional): The symbol of the token\n- initialSupply (int, optional): The initial supply of the token\n- supplyType (str, optional): The supply type of the token. Can be \"finite\" or \"infinite\". Defaults to \"finite\"\n- maxSupply (int, optional): The maximum supply of the token. Only applicable if supplyType is \"finite\". Defaults to 1,000,000 if not specified\n- decimals (int, optional): The number of decimals the token supports. Defaults to 0\n- ${treasuryAccountDesc}\n- isSupplyKey (boolean, optional): If user wants to set supply key set to true, otherwise false\n${usageInstructions}\n`;\n};\n\nconst createFungibleToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof createFungibleTokenParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const normalisedParams = await HederaParameterNormaliser.normaliseCreateFungibleTokenParams(\n      params,\n      context,\n      client,\n      mirrornodeService,\n    );\n    const tx = HederaBuilder.createFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    console.error('[CreateFungibleToken] Error creating fungible token:', error);\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Failed to create fungible token';\n  }\n};\n\nexport const CREATE_FUNGIBLE_TOKEN_TOOL = 'create_fungible_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: CREATE_FUNGIBLE_TOKEN_TOOL,\n  name: 'Create Fungible Token',\n  description: createFungibleTokenPrompt(context),\n  parameters: createFungibleTokenParameters(context),\n  execute: createFungibleToken,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client } from '@hashgraph/sdk';\nimport { handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport { mintFungibleTokenParameters } from '@/shared/parameter-schemas/hts.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst mintFungibleTokenPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will mint a given amount (supply) of an existing fungible token on Hedera.\n\nParameters:\n- tokenId (str, required): The id of the token\n- amount (number, required): The amount to be minted\n${usageInstructions}\n\nExample: \"Mint 1 of 0.0.6458037\" means minting the amount of 1 of the token with id 0.0.6458037.\n`;\n};\n\nconst mintFungibleToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof mintFungibleTokenParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const normalisedParams = await HederaParameterNormaliser.normaliseMintFungibleTokenParams(\n      params,\n      context,\n      mirrornodeService,\n    );\n    const tx = HederaBuilder.mintFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Failed to mint fungible token';\n  }\n};\n\nexport const MINT_FUNGIBLE_TOKEN_TOOL = 'mint_fungible_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: MINT_FUNGIBLE_TOKEN_TOOL,\n  name: 'Mint Fungible Token',\n  description: mintFungibleTokenPrompt(context),\n  parameters: mintFungibleTokenParameters(context),\n  execute: mintFungibleToken,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client } from '@hashgraph/sdk';\nimport { handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport { createNonFungibleTokenParameters } from '@/shared/parameter-schemas/hts.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst createNonFungibleTokenPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const treasuryAccountDesc = PromptGenerator.getAccountParameterDescription(\n    'treasuryAccountId',\n    context,\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool creates a non-fungible token (NFT) on Hedera.\n\nParameters:\n- tokenName (str, required): Name of the token\n- tokenSymbol (str, required): Symbol of the token\n- maxSupply (int, optional): Maximum NFT supply. Defaults to 100 if not provided\n- ${treasuryAccountDesc}\n${usageInstructions}\n`;\n};\n\nconst createNonFungibleToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof createNonFungibleTokenParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const normalisedParams = await HederaParameterNormaliser.normaliseCreateNonFungibleTokenParams(\n      params,\n      context,\n      client,\n      mirrornodeService,\n    );\n    const tx = HederaBuilder.createNonFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Failed to create non-fungible token';\n  }\n};\n\nexport const CREATE_NON_FUNGIBLE_TOKEN_TOOL = 'create_non_fungible_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: CREATE_NON_FUNGIBLE_TOKEN_TOOL,\n  name: 'Create Non-Fungible Token',\n  description: createNonFungibleTokenPrompt(context),\n  parameters: createNonFungibleTokenParameters(context),\n  execute: createNonFungibleToken,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client } from '@hashgraph/sdk';\nimport { handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport { mintNonFungibleTokenParameters } from '@/shared/parameter-schemas/hts.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst mintNonFungibleTokenPrompt = (_context: Context = {}) => {\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n\nThis tool will mint NFTs with its unique metadata for the class of NFTs (non-fungible tokens) defined by the tokenId on Hedera.\n\nParameters:\n- tokenId (str, required): The id of the token\n- uris (array, required): An array of strings (URIs) of maximum size 10 hosting the NFT metadata\n${usageInstructions}\n\nExample: \"Mint 0.0.6465503 with metadata: ipfs://bafyreiao6ajgsfji6qsgbqwdtjdu5gmul7tv2v3pd6kjgcw5o65b2ogst4/metadata.json\" means minting an NFT with the given metadata URI for the class of NFTs defined by the token with id 0.0.6465503.\n`;\n};\n\nconst mintNonFungibleToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof mintNonFungibleTokenParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseMintNonFungibleTokenParams(\n      params,\n      context,\n    );\n    const tx = HederaBuilder.mintNonFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Failed to mint non-fungible token';\n  }\n};\n\nexport const MINT_NON_FUNGIBLE_TOKEN_TOOL = 'mint_non_fungible_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: MINT_NON_FUNGIBLE_TOKEN_TOOL,\n  name: 'Mint Non-Fungible Token',\n  description: mintNonFungibleTokenPrompt(context),\n  parameters: mintNonFungibleTokenParameters(context),\n  execute: mintNonFungibleToken,\n});\n\nexport default tool;\n","import { Context } from '@/shared';\nimport { Plugin } from '@/shared/plugin';\nimport airdropFungibleToken, {\n  AIRDROP_FUNGIBLE_TOKEN_TOOL,\n} from '@/plugins/core-hts-plugin/tools/fungible-token/airdrop-fungible-token';\nimport createFungibleTokenTool, {\n  CREATE_FUNGIBLE_TOKEN_TOOL,\n} from '@/plugins/core-hts-plugin/tools/fungible-token/create-fungible-token';\nimport mintFungibleTokenTool, {\n  MINT_FUNGIBLE_TOKEN_TOOL,\n} from '@/plugins/core-hts-plugin/tools/fungible-token/mint-fungible-token';\nimport createNonFungibleTokenTool, {\n  CREATE_NON_FUNGIBLE_TOKEN_TOOL,\n} from '@/plugins/core-hts-plugin/tools/non-fungible-token/create-non-fungible-token';\nimport mintNonFungibleTokenTool, {\n  MINT_NON_FUNGIBLE_TOKEN_TOOL,\n} from '@/plugins/core-hts-plugin/tools/non-fungible-token/mint-non-fungible-token';\n\nexport const coreHTSPlugin: Plugin = {\n  name: 'core-hts-plugin',\n  version: '1.0.0',\n  description: 'A plugin for the Hedera Transaction Service',\n  tools: (context: Context) => {\n    return [\n      createFungibleTokenTool(context),\n      mintFungibleTokenTool(context),\n      createNonFungibleTokenTool(context),\n      airdropFungibleToken(context),\n      mintNonFungibleTokenTool(context),\n    ];\n  },\n};\n\n// Export tool names as an object for destructuring\nexport const coreHTSPluginToolNames = {\n  AIRDROP_FUNGIBLE_TOKEN_TOOL,\n  CREATE_FUNGIBLE_TOKEN_TOOL,\n  MINT_FUNGIBLE_TOKEN_TOOL,\n  CREATE_NON_FUNGIBLE_TOKEN_TOOL,\n  MINT_NON_FUNGIBLE_TOKEN_TOOL,\n} as const;\n\nexport default { coreHTSPlugin, coreHTSPluginToolNames };\n","import { Context } from '@/shared/configuration';\nimport { z } from 'zod';\nimport { AccountId, Hbar } from '@hashgraph/sdk';\nimport BigNumber from 'bignumber.js';\nimport Long from 'long';\n\nexport const transferHbarParameters = (_context: Context = {}) =>\n  z.object({\n    transfers: z\n      .array(\n        z.object({\n          accountId: z.string().describe('Recipient account ID'),\n          amount: z.number().describe('Amount of HBAR to transfer'),\n        }),\n      )\n      .describe('Array of HBAR transfers'),\n    sourceAccountId: z.string().optional().describe('Sender account ID'),\n    transactionMemo: z.string().optional().describe('Memo to include with the transaction'),\n  });\n\nexport const transferHbarParametersNormalised = (_context: Context = {}) =>\n  z.object({\n    hbarTransfers: z.array(\n      z.object({\n        accountId: z.union([z.string(), z.instanceof(AccountId)]),\n        amount: z.union([\n          z.number(),\n          z.string(),\n          z.instanceof(Hbar),\n          z.instanceof(Long),\n          z.instanceof(BigNumber),\n        ]),\n      }),\n    ),\n    transactionMemo: z.string().optional(),\n  });\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client } from '@hashgraph/sdk';\nimport { handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { transferHbarParameters } from '@/shared/parameter-schemas/has.zod';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst transferHbarPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(\n    'sourceAccountId',\n    context,\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will transfer HBAR to an account.\n\nParameters:\n- hbarAmount (number, required): Amount of HBAR to transfer\n- destinationAccountId (str, required): Account to transfer HBAR to\n- ${sourceAccountDesc}\n- transactionMemo (str, optional): Optional memo for the transaction\n${usageInstructions}\n`;\n};\n\nconst transferHbar = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof transferHbarParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseTransferHbar(\n      params,\n      context,\n      client,\n    );\n    const tx = HederaBuilder.transferHbar(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Failed to transfer HBAR';\n  }\n};\n\nexport const TRANSFER_HBAR_TOOL = 'transfer_hbar_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: TRANSFER_HBAR_TOOL,\n  name: 'Transfer HBAR',\n  description: transferHbarPrompt(context),\n  parameters: transferHbarParameters(context),\n  execute: transferHbar,\n});\n\nexport default tool;\n","import { Context } from '@/shared';\nimport { Plugin } from '@/shared/plugin';\nimport transferHbarTool, {\n  TRANSFER_HBAR_TOOL,\n} from '@/plugins/core-account-plugin/tools/account/transfer-hbar';\n\nexport const coreAccountPlugin: Plugin = {\n  name: 'core-account-plugin',\n  version: '1.0.0',\n  description: 'A plugin for the Hedera Account Service',\n  tools: (context: Context) => {\n    return [transferHbarTool(context)];\n  },\n};\n\nexport const coreAccountPluginToolNames = {\n  TRANSFER_HBAR_TOOL,\n} as const;\n\nexport default { coreAccountPlugin, coreAccountPluginToolNames };\n","import { z } from 'zod';\nimport { Context } from '@/shared/configuration';\nimport { PublicKey } from '@hashgraph/sdk';\n\nexport const createTopicParameters = (_context: Context = {}) => {\n  return z.object({\n    isSubmitKey: z\n      .boolean()\n      .optional()\n      .default(false)\n      .describe('Whether to set a submit key for the topic (optional)'),\n    topicMemo: z.string().optional().describe('Memo for the topic (optional)'),\n  });\n};\n\nexport const createTopicParametersNormalised = (_context: Context = {}) =>\n  createTopicParameters(_context).extend({\n    autoRenewAccountId: z\n      .string()\n      .describe(\n        'The auto renew account for the topic. If not provided, defaults to the operator account.',\n      ),\n    submitKey: z.custom<PublicKey>().optional().describe('The submit key of topic'),\n  });\n\nexport const submitTopicMessageParameters = (_context: Context = {}) => {\n  return z.object({\n    topicId: z.string().describe('The ID of the topic to submit the message to'),\n    message: z.string().describe('The message to submit to the topic'),\n  });\n};\n\nexport const submitTopicMessageParametersNormalised = (_context: Context = {}) =>\n  submitTopicMessageParameters(_context).extend({}); // currently no additional fields are needed\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client } from '@hashgraph/sdk';\nimport { handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { createTopicParameters } from '@/shared/parameter-schemas/hcs.zod';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { IHederaMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-service.interface';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst createTopicPrompt = (_context: Context = {}) => {\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\nThis tool will create a new topic on the Hedera network.\n\nParameters:\n- topicMemo (str, optional): A memo for the topic\n- isSubmitKey (bool, optional): Whether to set a submit key for the topic. Set to true if user wants to set a submit key, otherwise false\n${usageInstructions}\n`;\n};\n\nconst createTopic = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof createTopicParameters>>,\n) => {\n  try {\n    const mirrornodeService: IHederaMirrornodeService = getMirrornodeService(\n      context.mirrornodeService!,\n      client.ledgerId!,\n    );\n    const normalisedParams = await HederaParameterNormaliser.normaliseCreateTopicParams(\n      params,\n      context,\n      client,\n      mirrornodeService,\n    );\n    const tx = HederaBuilder.createTopic(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    console.error('[CreateTopic] Error creating topic:', error);\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Failed to create topic';\n  }\n};\n\nexport const CREATE_TOPIC_TOOL = 'create_topic_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: CREATE_TOPIC_TOOL,\n  name: 'Create Topic',\n  description: createTopicPrompt(context),\n  parameters: createTopicParameters(context),\n  execute: createTopic,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client } from '@hashgraph/sdk';\nimport { handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { submitTopicMessageParameters } from '@/shared/parameter-schemas/hcs.zod';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst submitTopicMessagePrompt = (_context: Context = {}) => {\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\nThis tool will submit a message to a topic on the Hedera network.\n\nParameters:\n- topicId (str, required): The ID of the topic to submit the message to\n- message (str, required): The message to submit to the topic\n${usageInstructions}\n`;\n};\n\nconst submitTopicMessage = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof submitTopicMessageParameters>>,\n) => {\n  try {\n    const tx = HederaBuilder.submitTopicMessage(params);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Failed to submit message to topic';\n  }\n};\n\nexport const SUBMIT_TOPIC_MESSAGE_TOOL = 'submit_topic_message_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: SUBMIT_TOPIC_MESSAGE_TOOL,\n  name: 'Submit Topic Message',\n  description: submitTopicMessagePrompt(context),\n  parameters: submitTopicMessageParameters(context),\n  execute: submitTopicMessage,\n});\n\nexport default tool;\n","import { Context } from '@/shared';\nimport { Plugin } from '@/shared/plugin';\nimport createTopicTool, {\n  CREATE_TOPIC_TOOL,\n} from '@/plugins/core-consensus-plugin/tools/consensus/create-topic';\nimport submitTopicMessageTool, {\n  SUBMIT_TOPIC_MESSAGE_TOOL,\n} from '@/plugins/core-consensus-plugin/tools/consensus/submit-topic-message';\n\nexport const coreConsensusPlugin: Plugin = {\n  name: 'core-consensus-plugin',\n  version: '1.0.0',\n  description: 'A plugin for the Hedera Consensus Service',\n  tools: (context: Context) => {\n    return [createTopicTool(context), submitTopicMessageTool(context)];\n  },\n};\n\nexport const coreConsensusPluginToolNames = {\n  CREATE_TOPIC_TOOL,\n  SUBMIT_TOPIC_MESSAGE_TOOL,\n} as const;\n\nexport default { coreConsensusPlugin, coreConsensusPluginToolNames };\n","import { z } from 'zod';\nimport { Context } from '@/shared/configuration';\n\n// add a description to the parameters\nexport const accountQueryParameters = (_context: Context = {}) =>\n  z.object({\n    accountId: z.string().describe('The account ID to query.'),\n  });\n\n//add a description to the parameters\nexport const accountBalanceQueryParameters = (_context: Context = {}) =>\n  z.object({\n    accountId: z.string().optional().describe('The account ID to query.'),\n  });\n\n//add a description to the parameters\nexport const accountTokenBalancesQueryParameters = (_context: Context = {}) =>\n  z.object({\n    accountId: z\n      .string()\n      .optional()\n      .describe('The account ID to query. If not provided, this accountId will be used.'),\n    tokenId: z.string().optional().describe('The token ID to query.'),\n  });\n\nexport const topicMessagesQueryParameters = (_context: Context = {}) =>\n  z.object({\n    topicId: z.string().describe('The topic ID to query.'),\n    startTime: z\n      .string()\n      .datetime()\n      .optional()\n      .describe(\n        'The start time to query. If set, the messages will be returned after this timestamp.',\n      ),\n    endTime: z\n      .string()\n      .datetime()\n      .optional()\n      .describe(\n        'The end time to query. If set, the messages will be returned before this timestamp.',\n      ),\n    limit: z\n      .number()\n      .optional()\n      .describe('The limit of messages to query. If set, the number of messages to return.'),\n  });\n","/**\n * Converts a tinybar amount to a hbar amount.\n * @param tinyBars - The tinybar amount.\n * @returns The hbar amount.\n */\nexport function toHBar(tinyBars: BigNumber): BigNumber {\n  return tinyBars.div(100000000);\n}\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client } from '@hashgraph/sdk';\nimport { accountBalanceQueryParameters } from '@/shared/parameter-schemas/account-query.zod';\nimport BigNumber from 'bignumber.js';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { toHBar } from '@/shared/hedera-utils/hbar-conversion-utils';\n\nexport const getHbarBalanceQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription('accountId', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the HBAR balance for a given Hedera account.\n\nParameters:\n- ${accountDesc}\n${usageInstructions}\n`;\n};\n\nexport const getHbarBalanceQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof accountBalanceQueryParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseHbarBalanceParams(\n      params,\n      context,\n      client,\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const balance: BigNumber = await mirrornodeService.getAccountHBarBalance(\n      normalisedParams.accountId,\n    );\n    return { accountId: normalisedParams.accountId, hbarBalance: toHBar(balance).toString() };\n  } catch (error) {\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Failed to get HBAR balance';\n  }\n};\n\nexport const GET_HBAR_BALANCE_QUERY_TOOL = 'get_hbar_balance_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_HBAR_BALANCE_QUERY_TOOL,\n  name: 'Get HBAR Balance',\n  description: getHbarBalanceQueryPrompt(context),\n  parameters: accountBalanceQueryParameters(context),\n  execute: getHbarBalanceQuery,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport { Client } from '@hashgraph/sdk';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { accountQueryParameters } from '@/shared/parameter-schemas/account-query.zod';\nimport { Tool } from '@/shared/tools';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nexport const getAccountQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the account information for a given Hedera account.\n\nParameters:\n- accountId (str, required): The account ID to query\n${usageInstructions}\n`;\n};\n\nexport const getAccountQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof accountQueryParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const account = await mirrornodeService.getAccount(params.accountId);\n    return { accountId: params.accountId, account: account };\n  } catch (error) {\n    console.error('Error getting account query', error);\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Failed to get account query';\n  }\n};\n\nexport const GET_ACCOUNT_QUERY_TOOL = 'get_account_query_tool';\n\nconst getAccountQueryTool = (context: Context): Tool => ({\n  method: GET_ACCOUNT_QUERY_TOOL,\n  name: 'Get Account Query',\n  description: getAccountQueryPrompt(context),\n  parameters: accountQueryParameters(context),\n  execute: getAccountQuery,\n});\n\nexport default getAccountQueryTool;\n","import { z } from 'zod';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { accountTokenBalancesQueryParameters } from '@/shared/parameter-schemas/account-query.zod';\nimport { Client } from '@hashgraph/sdk';\nimport { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nexport const getAccountTokenBalancesQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription('accountId', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the token balances for a given Hedera account.\n\nParameters:\n- ${accountDesc}\n- tokenId (str, optional): The token ID to query for. If not provided, all token balances will be returned\n${usageInstructions}\n`;\n};\n\nexport const getAccountTokenBalancesQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof accountTokenBalancesQueryParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseAccountTokenBalancesParams(\n      params,\n      context,\n      client,\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const tokenBalances = await mirrornodeService.getAccountTokenBalances(\n      normalisedParams.accountId,\n      normalisedParams.tokenId,\n    );\n    return { accountId: normalisedParams.accountId, tokenBalances: tokenBalances };\n  } catch (error) {\n    console.error('Error getting account token balances', error);\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Failed to get account token balances';\n  }\n};\n\nexport const GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL = 'get_account_token_balances_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,\n  name: 'Get Account Token Balances',\n  description: getAccountTokenBalancesQueryPrompt(context),\n  parameters: accountTokenBalancesQueryParameters(context),\n  execute: getAccountTokenBalancesQuery,\n});\n\nexport default tool;\n","import { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { topicMessagesQueryParameters } from '@/shared/parameter-schemas/account-query.zod';\nimport { Client } from '@hashgraph/sdk';\nimport { z } from 'zod';\nimport { Tool } from '@/shared/tools';\nimport { TopicMessage, TopicMessagesQueryParams } from '@/shared/hedera-utils/mirrornode/types';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nexport const getTopicMessagesQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the messages for a given Hedera topic.\n\nParameters:\n- topicId (str, required): The topic ID to query\n- startTime (datetime, optional): The start datetime to query. If set, the messages will be returned after this datetime\n- endTime (datetime, optional): The end datetime to query. If set, the messages will be returned before this datetime\n- limit (int, optional): The limit of messages to query. If set, the number of messages to return\n${usageInstructions}\n`;\n};\n\nconst getTopicMessagesQueryParams = (\n  params: z.infer<ReturnType<typeof topicMessagesQueryParameters>>,\n): TopicMessagesQueryParams => {\n  return {\n    topicId: params.topicId,\n    lowerTimestamp: params.startTime\n      ? `${Math.floor(new Date(params.startTime).getTime() / 1000)}.000000000`\n      : '',\n    upperTimestamp: params.endTime\n      ? `${Math.floor(new Date(params.endTime).getTime() / 1000)}.000000000`\n      : '',\n    limit: params.limit || 100,\n  };\n};\n\nconst convertMessagesFromBase64ToString = (messages: TopicMessage[]) => {\n  return messages.map(message => {\n    return {\n      ...message,\n      message: Buffer.from(message.message, 'base64').toString('utf-8'),\n    };\n  });\n};\n\nexport const getTopicMessagesQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof topicMessagesQueryParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const messages = await mirrornodeService.getTopicMessages(getTopicMessagesQueryParams(params));\n\n    return {\n      topicId: messages.topicId,\n      messages: convertMessagesFromBase64ToString(messages.messages),\n    };\n  } catch (error) {\n    console.error('Error getting topic messages', error);\n    if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Failed to get topic messages';\n  }\n};\n\nexport const GET_TOPIC_MESSAGES_QUERY_TOOL = 'get_topic_messages_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_TOPIC_MESSAGES_QUERY_TOOL,\n  name: 'Get Topic Messages',\n  description: getTopicMessagesQueryPrompt(context),\n  parameters: topicMessagesQueryParameters(context),\n  execute: getTopicMessagesQuery,\n});\n\nexport default tool;\n","import { Plugin } from '@/shared/plugin';\nimport { Context } from '@/shared/configuration';\nimport getHbarBalanceQuery, {\n  GET_HBAR_BALANCE_QUERY_TOOL,\n} from '@/plugins/core-queries-plugin/tools/queries/get-hbar-balance-query';\nimport getAccountQuery, {\n  GET_ACCOUNT_QUERY_TOOL,\n} from '@/plugins/core-queries-plugin/tools/queries/get-account-query';\nimport getAccountTokenBalancesQuery, {\n  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,\n} from '@/plugins/core-queries-plugin/tools/queries/get-account-token-balances-query';\nimport getTopicMessagesQuery, {\n  GET_TOPIC_MESSAGES_QUERY_TOOL,\n} from '@/plugins/core-queries-plugin/tools/queries/get-topic-messages-query';\n\nexport const coreQueriesPlugin: Plugin = {\n  name: 'core-queries-plugin',\n  version: '1.0.0',\n  description: 'A plugin for the Hedera Queries Service',\n  tools: (context: Context) => {\n    return [\n      getHbarBalanceQuery(context),\n      getAccountQuery(context),\n      getAccountTokenBalancesQuery(context),\n      getTopicMessagesQuery(context),\n    ];\n  },\n};\n\nexport const coreQueriesPluginToolNames = {\n  GET_HBAR_BALANCE_QUERY_TOOL,\n  GET_ACCOUNT_QUERY_TOOL,\n  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,\n  GET_TOPIC_MESSAGES_QUERY_TOOL,\n} as const;\n\nexport default { coreQueriesPlugin, coreQueriesPluginToolNames };\n"],"mappings":"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","names":["toolkit_default","tool","AgentMode","tool","tool","tool","toolkit_default","HederaAgentKitTool","tool","HederaAgentKitTool","toolkit_default","import_sdk","Long","import_sdk","import_sdk","import_sdk","BigNumber","tool","tool","tool","tool","tool","import_zod","import_sdk","import_bignumber","import_long","tool","import_zod","tool","tool","import_zod","tool","tool","tool"]}