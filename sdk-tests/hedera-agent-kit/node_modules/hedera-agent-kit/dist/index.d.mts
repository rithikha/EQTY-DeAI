import * as _hashgraph_sdk from '@hashgraph/sdk';
import { TokenType, Client, Transaction, AccountId, TransactionId } from '@hashgraph/sdk';
import BigNumber$1 from 'bignumber.js';
import { z } from 'zod';
import { StructuredTool, BaseToolkit } from '@langchain/core/tools';
import { CallbackManagerForToolRun } from '@langchain/core/callbacks/manager';
import { RunnableConfig } from '@langchain/core/runnables';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { Tool as Tool$1, LanguageModelV1Middleware } from 'ai';

type TopicMessagesQueryParams = {
    topicId: string;
    lowerTimestamp: string;
    upperTimestamp: string;
    limit: number;
};
type TopicMessage = {
    topicId: string;
    message: string;
    timestamp: string;
};
type TopicMessagesResponse = {
    topicId: string;
    messages: TopicMessage[];
};
type TokenBalance = {
    account: string;
    balance: number;
    decimals: number;
};
type TokenBalancesResponse = {
    tokens: TokenBalance[];
};
type AccountResponse = {
    accountId: string;
    accountPublicKey: string;
    balance: AccountBalanceResponse;
};
type AccountBalanceResponse = {
    balance: BigNumber$1;
    timestamp: string;
    tokens: TokenBalance[];
};
type TokenDetails = {
    decimals: string;
    name: string;
    symbol: string;
    maxSupply: number;
    type: TokenType;
};

interface IHederaMirrornodeService {
    getAccount(accountId: string): Promise<AccountResponse>;
    getAccountHBarBalance(accountId: string): Promise<BigNumber>;
    getAccountTokenBalances(accountId: string): Promise<TokenBalancesResponse>;
    getTopicMessages(queryParams: TopicMessagesQueryParams): Promise<TopicMessagesResponse>;
    getTokenDetails(tokenId: string): Promise<TokenDetails>;
}

type Tool = {
    method: string;
    name: string;
    description: string;
    parameters: z.ZodObject<any, any>;
    execute: (client: Client, context: Context, params: any) => Promise<any>;
};

interface Plugin {
    name: string;
    version?: string;
    description?: string;
    tools: (context: Context) => Tool[];
}
declare class PluginRegistry {
    private plugins;
    register(plugin: Plugin): void;
    getPlugins(): Plugin[];
    getTools(context: Context): Tool[];
    clear(): void;
}

declare enum AgentMode {
    AUTONOMOUS = "autonomous",
    RETURN_BYTES = "returnBytes"
}
type Context = {
    accountId?: string;
    accountPublicKey?: string;
    mode?: AgentMode;
    mirrornodeService?: IHederaMirrornodeService;
};
type Configuration = {
    tools?: string[];
    plugins?: Plugin[];
    context?: Context;
};

declare class HederaAgentAPI {
    client: Client;
    context: Context;
    tools: Tool[];
    constructor(client: Client, context?: Context, tools?: Tool[]);
    run(method: string, arg: unknown): Promise<string>;
}

declare class ToolDiscovery {
    private pluginRegistry;
    constructor(plugins?: Plugin[]);
    getAllTools(context: Context, configuration?: Configuration): Tool[];
    static createFromConfiguration(configuration: Configuration): ToolDiscovery;
}

declare const handleTransaction: (tx: Transaction, client: Client, context: Context) => Promise<{
    bytes: Uint8Array<ArrayBufferLike>;
} | {
    status: number;
    accountId: AccountId | null;
    tokenId: _hashgraph_sdk.TokenId | null;
    transactionId: TransactionId | null;
    topicId: _hashgraph_sdk.TopicId | null;
    contractId: _hashgraph_sdk.ContractId | null;
    receipt: _hashgraph_sdk.TransactionReceipt;
}>;

declare class AccountResolver {
    /**
     * Gets the default account based on the agent mode and context.
     * In RETURN_BYTES mode, prefers context.accountId (user's account).
     * In AUTONOMOUS mode or when no context account, uses operator account.
     */
    static getDefaultAccount(context: Context, client: Client): string;
    /**
     * Resolves an account ID, using the provided account or falling back to the default.
     */
    static resolveAccount(providedAccount: string | undefined, context: Context, client: Client): string;
    /**
     * Gets a description of which account will be used as default for prompts.
     */
    static getDefaultAccountDescription(context: Context): string;
}

declare class PromptGenerator {
    /**
     * Generates a consistent context snippet for tool prompts.
     */
    static getContextSnippet(context: Context): string;
    /**
     * Generates a consistent description for optional account parameters.
     */
    static getAccountParameterDescription(paramName: string, context: Context, isRequired?: boolean): string;
    /**
     * Generates consistent parameter usage instructions.
     */
    static getParameterUsageInstructions(): string;
}

declare class HederaAgentKitTool extends StructuredTool {
    hederaAPI: HederaAgentAPI;
    method: string;
    name: string;
    description: string;
    schema: z.ZodObject<any, any>;
    constructor(HederaAgentKitAPI: HederaAgentAPI, method: string, description: string, schema: z.ZodObject<any, any>);
    _call(arg: z.output<typeof this.schema>, _runManager?: CallbackManagerForToolRun, _parentConfig?: RunnableConfig): Promise<any>;
}

declare class HederaLangchainToolkit implements BaseToolkit {
    private _hederaAgentKit;
    tools: HederaAgentKitTool[];
    constructor({ client, configuration }: {
        client: Client;
        configuration: Configuration;
    });
    getTools(): HederaAgentKitTool[];
}

declare class HederaMCPToolkit extends McpServer {
    private _hederaAgentKit;
    constructor({ client, configuration }: {
        client: Client;
        configuration: Configuration;
    });
}

declare class HederaAIToolkit {
    private _hedera;
    tools: {
        [key: string]: Tool$1;
    };
    constructor({ client, configuration }: {
        client: Client;
        configuration: Configuration;
    });
    middleware(): LanguageModelV1Middleware;
    getTools(): {
        [key: string]: Tool$1;
    };
}

declare const coreHTSPlugin: Plugin;
declare const coreHTSPluginToolNames: {
    readonly AIRDROP_FUNGIBLE_TOKEN_TOOL: "airdrop_fungible_token_tool";
    readonly CREATE_FUNGIBLE_TOKEN_TOOL: "create_fungible_token_tool";
    readonly MINT_FUNGIBLE_TOKEN_TOOL: "mint_fungible_token_tool";
    readonly CREATE_NON_FUNGIBLE_TOKEN_TOOL: "create_non_fungible_token_tool";
    readonly MINT_NON_FUNGIBLE_TOKEN_TOOL: "mint_non_fungible_token_tool";
};

declare const coreAccountPlugin: Plugin;
declare const coreAccountPluginToolNames: {
    readonly TRANSFER_HBAR_TOOL: "transfer_hbar_tool";
};

declare const coreConsensusPlugin: Plugin;
declare const coreConsensusPluginToolNames: {
    readonly CREATE_TOPIC_TOOL: "create_topic_tool";
    readonly SUBMIT_TOPIC_MESSAGE_TOOL: "submit_topic_message_tool";
};

declare const coreQueriesPlugin: Plugin;
declare const coreQueriesPluginToolNames: {
    readonly GET_HBAR_BALANCE_QUERY_TOOL: "get_hbar_balance_query_tool";
    readonly GET_ACCOUNT_QUERY_TOOL: "get_account_query_tool";
    readonly GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL: "get_account_token_balances_query_tool";
    readonly GET_TOPIC_MESSAGES_QUERY_TOOL: "get_topic_messages_query_tool";
};

export { AccountResolver, AgentMode, type Configuration, type Context, HederaAIToolkit, HederaLangchainToolkit, HederaMCPToolkit, type Plugin, PluginRegistry, PromptGenerator, type Tool, ToolDiscovery, coreAccountPlugin, coreAccountPluginToolNames, coreConsensusPlugin, coreConsensusPluginToolNames, coreHTSPlugin, coreHTSPluginToolNames, coreQueriesPlugin, coreQueriesPluginToolNames, handleTransaction };
